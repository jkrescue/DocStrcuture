{"version":3,"file":"comments.js","sources":["../src/comments/threadstore/ThreadStoreAuth.ts","../src/comments/threadstore/DefaultThreadStoreAuth.ts","../src/comments/threadstore/ThreadStore.ts","../src/comments/threadstore/TipTapThreadStore.ts","../src/comments/threadstore/yjs/yjsHelpers.ts","../src/comments/threadstore/yjs/YjsThreadStoreBase.ts","../src/comments/threadstore/yjs/RESTYjsThreadStore.ts","../src/comments/threadstore/yjs/YjsThreadStore.ts"],"sourcesContent":["import { CommentData, ThreadData } from \"../types.js\";\n\nexport abstract class ThreadStoreAuth {\n  abstract canCreateThread(): boolean;\n  abstract canAddComment(thread: ThreadData): boolean;\n  abstract canUpdateComment(comment: CommentData): boolean;\n  abstract canDeleteComment(comment: CommentData): boolean;\n  abstract canDeleteThread(thread: ThreadData): boolean;\n  abstract canResolveThread(thread: ThreadData): boolean;\n  abstract canUnresolveThread(thread: ThreadData): boolean;\n  abstract canAddReaction(comment: CommentData, emoji?: string): boolean;\n  abstract canDeleteReaction(comment: CommentData, emoji?: string): boolean;\n}\n","import { CommentData, ThreadData } from \"../types.js\";\nimport { ThreadStoreAuth } from \"./ThreadStoreAuth.js\";\n\n/*\n * The DefaultThreadStoreAuth class defines the authorization rules for interacting with comments.\n * We take a role (\"comment\" or \"editor\") and implement the rules.\n *\n * This class is then used in the UI to show / hide specific interactions.\n *\n * Rules:\n * - View-only users should not be able to see any comments\n * - Comment-only users and editors can:\n * - - create new comments / replies / reactions\n * - - edit / delete their own comments / reactions\n * - - resolve / unresolve threads\n * - Editors can also delete any comment or thread\n */\nexport class DefaultThreadStoreAuth extends ThreadStoreAuth {\n  constructor(\n    private readonly userId: string,\n    private readonly role: \"comment\" | \"editor\",\n  ) {\n    super();\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   */\n  canCreateThread(): boolean {\n    return true;\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   */\n  canAddComment(_thread: ThreadData): boolean {\n    return true;\n  }\n\n  /**\n   * Auth: should only be possible by the comment author\n   */\n  canUpdateComment(comment: CommentData): boolean {\n    return comment.userId === this.userId;\n  }\n\n  /**\n   * Auth: should be possible by the comment author OR an editor of the document\n   */\n  canDeleteComment(comment: CommentData): boolean {\n    return comment.userId === this.userId || this.role === \"editor\";\n  }\n\n  /**\n   * Auth: should only be possible by an editor of the document\n   */\n  canDeleteThread(_thread: ThreadData): boolean {\n    return this.role === \"editor\";\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   */\n  canResolveThread(_thread: ThreadData): boolean {\n    return true;\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   */\n  canUnresolveThread(_thread: ThreadData): boolean {\n    return true;\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   *\n   * Note: will also check if the user has already reacted with the same emoji. TBD: is that a nice design or should this responsibility be outside of auth?\n   */\n  canAddReaction(comment: CommentData, emoji?: string): boolean {\n    if (!emoji) {\n      return true;\n    }\n\n    return !comment.reactions.some(\n      (reaction) =>\n        reaction.emoji === emoji && reaction.userIds.includes(this.userId),\n    );\n  }\n\n  /**\n   * Auth: should be possible by anyone with comment access\n   *\n   * Note: will also check if the user has already reacted with the same emoji. TBD: is that a nice design or should this responsibility be outside of auth?\n   */\n  canDeleteReaction(comment: CommentData, emoji?: string): boolean {\n    if (!emoji) {\n      return true;\n    }\n\n    return comment.reactions.some(\n      (reaction) =>\n        reaction.emoji === emoji && reaction.userIds.includes(this.userId),\n    );\n  }\n}\n","import { CommentBody, CommentData, ThreadData } from \"../types.js\";\nimport { ThreadStoreAuth } from \"./ThreadStoreAuth.js\";\n\n/**\n * ThreadStore is an abstract class that defines the interface\n * to read / add / update / delete threads and comments.\n */\nexport abstract class ThreadStore {\n  public readonly auth: ThreadStoreAuth;\n\n  constructor(auth: ThreadStoreAuth) {\n    this.auth = auth;\n  }\n\n  /**\n   * A \"thread\" in the ThreadStore only contains information about the content\n   * of the thread / comments. It does not contain information about the position.\n   *\n   * This function can be implemented to store the thread in the document (by creating a mark)\n   * If not implemented, default behavior will apply (creating the mark via TipTap)\n   * See CommentsPlugin.ts for more details.\n   */\n  abstract addThreadToDocument?(options: {\n    threadId: string;\n    selection: {\n      prosemirror: {\n        head: number;\n        anchor: number;\n      };\n      yjs?: {\n        head: any;\n        anchor: any;\n      };\n    };\n  }): Promise<void>;\n\n  /**\n   * Creates a new thread with an initial comment.\n   */\n  abstract createThread(options: {\n    initialComment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    metadata?: any;\n  }): Promise<ThreadData>;\n\n  /**\n   * Adds a comment to a thread.\n   */\n  abstract addComment(options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n  }): Promise<CommentData>;\n\n  /**\n   * Updates a comment in a thread.\n   */\n  abstract updateComment(options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  /**\n   * Deletes a comment from a thread.\n   */\n  abstract deleteComment(options: {\n    threadId: string;\n    commentId: string;\n  }): Promise<void>;\n\n  /**\n   * Deletes a thread.\n   */\n  abstract deleteThread(options: { threadId: string }): Promise<void>;\n\n  /**\n   * Marks a thread as resolved.\n   */\n  abstract resolveThread(options: { threadId: string }): Promise<void>;\n\n  /**\n   * Marks a thread as unresolved.\n   */\n  abstract unresolveThread(options: { threadId: string }): Promise<void>;\n\n  /**\n   * Adds a reaction to a comment.\n   *\n   * Auth: should be possible by anyone with comment access\n   */\n  abstract addReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  /**\n   * Deletes a reaction from a comment.\n   *\n   * Auth: should be possible by the reaction author\n   */\n  abstract deleteReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }): Promise<void>;\n\n  /**\n   * Retrieve data for a specific thread.\n   */\n  abstract getThread(threadId: string): ThreadData;\n\n  /**\n   * Retrieve all threads.\n   */\n  abstract getThreads(): Map<string, ThreadData>;\n\n  /**\n   * Subscribe to changes in the thread store.\n   *\n   * @returns a function to unsubscribe from the thread store\n   */\n  abstract subscribe(\n    cb: (threads: Map<string, ThreadData>) => void,\n  ): () => void;\n}\n","import type {\n  TCollabComment,\n  TCollabThread,\n  TiptapCollabProvider,\n} from \"@hocuspocus/provider\";\nimport {\n  CommentBody,\n  CommentData,\n  CommentReactionData,\n  ThreadData,\n} from \"../types.js\";\nimport { ThreadStore } from \"./ThreadStore.js\";\nimport { ThreadStoreAuth } from \"./ThreadStoreAuth.js\";\n\ntype ReactionAsTiptapData = {\n  emoji: string;\n  createdAt: number;\n  userId: string;\n};\n\n/**\n * The `TiptapThreadStore` integrates with Tiptap's collaboration provider for comment management.\n * You can pass a `TiptapCollabProvider` to the constructor which takes care of storing the comments.\n *\n * Under the hood, this actually works similarly to the `YjsThreadStore` implementation. (comments are stored in the Yjs document)\n */\nexport class TiptapThreadStore extends ThreadStore {\n  constructor(\n    private readonly userId: string,\n    private readonly provider: TiptapCollabProvider,\n    auth: ThreadStoreAuth, // TODO: use?\n  ) {\n    super(auth);\n  }\n\n  /**\n   * Creates a new thread with an initial comment.\n   */\n  public async createThread(options: {\n    initialComment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    metadata?: any;\n  }): Promise<ThreadData> {\n    let thread = this.provider.createThread({\n      data: options.metadata,\n    });\n\n    thread = this.provider.addComment(thread.id, {\n      content: options.initialComment.body,\n      data: {\n        metadata: options.initialComment.metadata,\n        userId: this.userId,\n      },\n    });\n\n    return this.tiptapThreadToThreadData(thread);\n  }\n\n  // TipTapThreadStore does not support addThreadToDocument\n  public addThreadToDocument = undefined;\n\n  /**\n   * Adds a comment to a thread.\n   */\n  public async addComment(options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n  }): Promise<CommentBody> {\n    const thread = this.provider.addComment(options.threadId, {\n      content: options.comment.body,\n      data: {\n        metadata: options.comment.metadata,\n        userId: this.userId,\n      },\n    });\n\n    return this.tiptapCommentToCommentData(\n      thread.comments[thread.comments.length - 1],\n    );\n  }\n\n  /**\n   * Updates a comment in a thread.\n   */\n  public async updateComment(options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n    commentId: string;\n  }) {\n    const comment = this.provider.getThreadComment(\n      options.threadId,\n      options.commentId,\n      true,\n    );\n\n    if (!comment) {\n      throw new Error(\"Comment not found\");\n    }\n\n    this.provider.updateComment(options.threadId, options.commentId, {\n      content: options.comment.body,\n      data: {\n        ...comment.data,\n        metadata: options.comment.metadata,\n      },\n    });\n  }\n\n  private tiptapCommentToCommentData(comment: TCollabComment): CommentData {\n    const reactions: CommentReactionData[] = [];\n\n    for (const reaction of (comment.data?.reactions ||\n      []) as ReactionAsTiptapData[]) {\n      const existingReaction = reactions.find(\n        (r) => r.emoji === reaction.emoji,\n      );\n      if (existingReaction) {\n        existingReaction.userIds.push(reaction.userId);\n        existingReaction.createdAt = new Date(\n          Math.min(existingReaction.createdAt.getTime(), reaction.createdAt),\n        );\n      } else {\n        reactions.push({\n          emoji: reaction.emoji,\n          createdAt: new Date(reaction.createdAt),\n          userIds: [reaction.userId],\n        });\n      }\n    }\n\n    return {\n      type: \"comment\",\n      id: comment.id,\n      body: comment.content,\n      metadata: comment.data?.metadata,\n      userId: comment.data?.userId,\n      createdAt: new Date(comment.createdAt),\n      updatedAt: new Date(comment.updatedAt),\n      reactions,\n    };\n  }\n\n  private tiptapThreadToThreadData(thread: TCollabThread): ThreadData {\n    return {\n      type: \"thread\",\n      id: thread.id,\n      comments: thread.comments.map((comment) =>\n        this.tiptapCommentToCommentData(comment),\n      ),\n      resolved: !!thread.resolvedAt,\n      metadata: thread.data?.metadata,\n      createdAt: new Date(thread.createdAt),\n      updatedAt: new Date(thread.updatedAt),\n    };\n  }\n\n  /**\n   * Deletes a comment from a thread.\n   */\n  public async deleteComment(options: { threadId: string; commentId: string }) {\n    this.provider.deleteComment(options.threadId, options.commentId);\n  }\n\n  /**\n   * Deletes a thread.\n   */\n  public async deleteThread(options: { threadId: string }) {\n    this.provider.deleteThread(options.threadId);\n  }\n\n  /**\n   * Marks a thread as resolved.\n   */\n  public async resolveThread(options: { threadId: string }) {\n    this.provider.updateThread(options.threadId, {\n      resolvedAt: new Date().toISOString(),\n    });\n  }\n\n  /**\n   * Marks a thread as unresolved.\n   */\n  public async unresolveThread(options: { threadId: string }) {\n    this.provider.updateThread(options.threadId, {\n      resolvedAt: null,\n    });\n  }\n\n  /**\n   * Adds a reaction to a comment.\n   *\n   * Auth: should be possible by anyone with comment access\n   */\n  public async addReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    const comment = this.provider.getThreadComment(\n      options.threadId,\n      options.commentId,\n      true,\n    );\n\n    if (!comment) {\n      throw new Error(\"Comment not found\");\n    }\n\n    this.provider.updateComment(options.threadId, options.commentId, {\n      data: {\n        ...comment.data,\n        reactions: [\n          ...((comment.data?.reactions || []) as ReactionAsTiptapData[]),\n          {\n            emoji: options.emoji,\n            createdAt: Date.now(),\n            userId: this.userId,\n          },\n        ],\n      },\n    });\n  }\n\n  /**\n   * Deletes a reaction from a comment.\n   *\n   * Auth: should be possible by the reaction author\n   */\n  public async deleteReaction(options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) {\n    const comment = this.provider.getThreadComment(\n      options.threadId,\n      options.commentId,\n      true,\n    );\n\n    if (!comment) {\n      throw new Error(\"Comment not found\");\n    }\n\n    this.provider.updateComment(options.threadId, options.commentId, {\n      data: {\n        ...comment.data,\n        reactions: (\n          (comment.data?.reactions || []) as ReactionAsTiptapData[]\n        ).filter(\n          (reaction) =>\n            reaction.emoji !== options.emoji && reaction.userId !== this.userId,\n        ),\n      },\n    });\n  }\n\n  public getThread(threadId: string): ThreadData {\n    const thread = this.provider.getThread(threadId);\n\n    if (!thread) {\n      throw new Error(\"Thread not found\");\n    }\n\n    return this.tiptapThreadToThreadData(thread);\n  }\n\n  public getThreads(): Map<string, ThreadData> {\n    return new Map(\n      this.provider\n        .getThreads()\n        .map((thread) => [thread.id, this.tiptapThreadToThreadData(thread)]),\n    );\n  }\n\n  public subscribe(cb: (threads: Map<string, ThreadData>) => void): () => void {\n    const newCb = () => {\n      cb(this.getThreads());\n    };\n    this.provider.watchThreads(newCb);\n    return () => {\n      this.provider.unwatchThreads(newCb);\n    };\n  }\n}\n","import * as Y from \"yjs\";\nimport { CommentData, CommentReactionData, ThreadData } from \"../../types.js\";\n\nexport function commentToYMap(comment: CommentData) {\n  const yMap = new Y.Map<any>();\n  yMap.set(\"id\", comment.id);\n  yMap.set(\"userId\", comment.userId);\n  yMap.set(\"createdAt\", comment.createdAt.getTime());\n  yMap.set(\"updatedAt\", comment.updatedAt.getTime());\n  if (comment.deletedAt) {\n    yMap.set(\"deletedAt\", comment.deletedAt.getTime());\n    yMap.set(\"body\", undefined);\n  } else {\n    yMap.set(\"body\", comment.body);\n  }\n  if (comment.reactions.length > 0) {\n    throw new Error(\"Reactions should be empty in commentToYMap\");\n  }\n\n  /**\n   * Reactions are stored in a map keyed by {userId-emoji},\n   * this makes it easy to add / remove reactions and in a way that works local-first.\n   * The cost is that \"reading\" the reactions is a bit more complex (see yMapToReactions).\n   */\n  yMap.set(\"reactionsByUser\", new Y.Map());\n  yMap.set(\"metadata\", comment.metadata);\n\n  return yMap;\n}\n\nexport function threadToYMap(thread: ThreadData) {\n  const yMap = new Y.Map();\n  yMap.set(\"id\", thread.id);\n  yMap.set(\"createdAt\", thread.createdAt.getTime());\n  yMap.set(\"updatedAt\", thread.updatedAt.getTime());\n  const commentsArray = new Y.Array<Y.Map<any>>();\n\n  commentsArray.push(thread.comments.map((comment) => commentToYMap(comment)));\n\n  yMap.set(\"comments\", commentsArray);\n  yMap.set(\"resolved\", thread.resolved);\n  yMap.set(\"resolvedUpdatedAt\", thread.resolvedUpdatedAt?.getTime());\n  yMap.set(\"resolvedBy\", thread.resolvedBy);\n  yMap.set(\"metadata\", thread.metadata);\n  return yMap;\n}\n\ntype SingleUserCommentReactionData = {\n  emoji: string;\n  createdAt: Date;\n  userId: string;\n};\n\nexport function yMapToReaction(\n  yMap: Y.Map<any>,\n): SingleUserCommentReactionData {\n  return {\n    emoji: yMap.get(\"emoji\"),\n    createdAt: new Date(yMap.get(\"createdAt\")),\n    userId: yMap.get(\"userId\"),\n  };\n}\n\nfunction yMapToReactions(yMap: Y.Map<any>): CommentReactionData[] {\n  const flatReactions = [...yMap.values()].map((reaction: Y.Map<any>) =>\n    yMapToReaction(reaction),\n  );\n  // combine reactions by the same emoji\n  return flatReactions.reduce(\n    (acc: CommentReactionData[], reaction: SingleUserCommentReactionData) => {\n      const existingReaction = acc.find((r) => r.emoji === reaction.emoji);\n      if (existingReaction) {\n        existingReaction.userIds.push(reaction.userId);\n        existingReaction.createdAt = new Date(\n          Math.min(\n            existingReaction.createdAt.getTime(),\n            reaction.createdAt.getTime(),\n          ),\n        );\n      } else {\n        acc.push({\n          emoji: reaction.emoji,\n          createdAt: reaction.createdAt,\n          userIds: [reaction.userId],\n        });\n      }\n      return acc;\n    },\n    [] as CommentReactionData[],\n  );\n}\n\nexport function yMapToComment(yMap: Y.Map<any>): CommentData {\n  return {\n    type: \"comment\",\n    id: yMap.get(\"id\"),\n    userId: yMap.get(\"userId\"),\n    createdAt: new Date(yMap.get(\"createdAt\")),\n    updatedAt: new Date(yMap.get(\"updatedAt\")),\n    deletedAt: yMap.get(\"deletedAt\")\n      ? new Date(yMap.get(\"deletedAt\"))\n      : undefined,\n    reactions: yMapToReactions(yMap.get(\"reactionsByUser\")),\n    metadata: yMap.get(\"metadata\"),\n    body: yMap.get(\"body\"),\n  };\n}\n\nexport function yMapToThread(yMap: Y.Map<any>): ThreadData {\n  return {\n    type: \"thread\",\n    id: yMap.get(\"id\"),\n    createdAt: new Date(yMap.get(\"createdAt\")),\n    updatedAt: new Date(yMap.get(\"updatedAt\")),\n    comments: ((yMap.get(\"comments\") as Y.Array<Y.Map<any>>) || []).map(\n      (comment) => yMapToComment(comment),\n    ),\n    resolved: yMap.get(\"resolved\"),\n    resolvedUpdatedAt: new Date(yMap.get(\"resolvedUpdatedAt\")),\n    resolvedBy: yMap.get(\"resolvedBy\"),\n    metadata: yMap.get(\"metadata\"),\n  };\n}\n","import * as Y from \"yjs\";\nimport { ThreadData } from \"../../types.js\";\nimport { ThreadStore } from \"../ThreadStore.js\";\nimport { ThreadStoreAuth } from \"../ThreadStoreAuth.js\";\nimport { yMapToThread } from \"./yjsHelpers.js\";\n\n/**\n * This is an abstract class that only implements the READ methods required by the ThreadStore interface.\n * The data is read from a Yjs Map.\n */\nexport abstract class YjsThreadStoreBase extends ThreadStore {\n  constructor(\n    protected readonly threadsYMap: Y.Map<any>,\n    auth: ThreadStoreAuth,\n  ) {\n    super(auth);\n  }\n\n  // TODO: async / reactive interface?\n  public getThread(threadId: string) {\n    const yThread = this.threadsYMap.get(threadId);\n    if (!yThread) {\n      throw new Error(\"Thread not found\");\n    }\n    const thread = yMapToThread(yThread);\n    return thread;\n  }\n\n  public getThreads(): Map<string, ThreadData> {\n    const threadMap = new Map<string, ThreadData>();\n    this.threadsYMap.forEach((yThread, id) => {\n      threadMap.set(id, yMapToThread(yThread));\n    });\n    return threadMap;\n  }\n\n  public subscribe(cb: (threads: Map<string, ThreadData>) => void) {\n    const observer = () => {\n      cb(this.getThreads());\n    };\n\n    this.threadsYMap.observeDeep(observer);\n\n    return () => {\n      this.threadsYMap.unobserveDeep(observer);\n    };\n  }\n}\n","import * as Y from \"yjs\";\nimport { CommentBody } from \"../../types.js\";\nimport { ThreadStoreAuth } from \"../ThreadStoreAuth.js\";\nimport { YjsThreadStoreBase } from \"./YjsThreadStoreBase.js\";\n\n/**\n * This is a REST-based implementation of the YjsThreadStoreBase.\n * It Reads data directly from the underlying document (same as YjsThreadStore),\n * but for Writes, it sends data to a REST API that should:\n * - check the user has the correct permissions to make the desired changes\n * - apply the updates to the underlying Yjs document\n *\n * (see https://github.com/TypeCellOS/BlockNote-demo-nextjs-hocuspocus)\n *\n * The reason we still use the Yjs document as underlying storage is that it makes it easy to\n * sync updates in real-time to other collaborators.\n * (but technically, you could also implement a different storage altogether\n * and not store the thread related data in the Yjs document)\n */\nexport class RESTYjsThreadStore extends YjsThreadStoreBase {\n  constructor(\n    private readonly BASE_URL: string,\n    private readonly headers: Record<string, string>,\n    threadsYMap: Y.Map<any>,\n    auth: ThreadStoreAuth,\n  ) {\n    super(threadsYMap, auth);\n  }\n\n  private doRequest = async (path: string, method: string, body?: any) => {\n    const response = await fetch(`${this.BASE_URL}${path}`, {\n      method,\n      body: JSON.stringify(body),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...this.headers,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to ${method} ${path}: ${response.statusText}`);\n    }\n\n    return response.json();\n  };\n\n  public addThreadToDocument = async (options: {\n    threadId: string;\n    selection: {\n      prosemirror: {\n        head: number;\n        anchor: number;\n      };\n      yjs: {\n        head: any;\n        anchor: any;\n      };\n    };\n  }) => {\n    const { threadId, ...rest } = options;\n    return this.doRequest(`/${threadId}/addToDocument`, \"POST\", rest);\n  };\n\n  public createThread = async (options: {\n    initialComment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    metadata?: any;\n  }) => {\n    return this.doRequest(\"\", \"POST\", options);\n  };\n\n  public addComment = (options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n  }) => {\n    const { threadId, ...rest } = options;\n    return this.doRequest(`/${threadId}/comments`, \"POST\", rest);\n  };\n\n  public updateComment = (options: {\n    comment: {\n      body: CommentBody;\n      metadata?: any;\n    };\n    threadId: string;\n    commentId: string;\n  }) => {\n    const { threadId, commentId, ...rest } = options;\n    return this.doRequest(`/${threadId}/comments/${commentId}`, \"PUT\", rest);\n  };\n\n  public deleteComment = (options: {\n    threadId: string;\n    commentId: string;\n    softDelete?: boolean;\n  }) => {\n    const { threadId, commentId, ...rest } = options;\n    return this.doRequest(\n      `/${threadId}/comments/${commentId}?soft=${!!rest.softDelete}`,\n      \"DELETE\",\n    );\n  };\n\n  public deleteThread = (options: { threadId: string }) => {\n    return this.doRequest(`/${options.threadId}`, \"DELETE\");\n  };\n\n  public resolveThread = (options: { threadId: string }) => {\n    return this.doRequest(`/${options.threadId}/resolve`, \"POST\");\n  };\n\n  public unresolveThread = (options: { threadId: string }) => {\n    return this.doRequest(`/${options.threadId}/unresolve`, \"POST\");\n  };\n\n  public addReaction = (options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) => {\n    const { threadId, commentId, ...rest } = options;\n    return this.doRequest(\n      `/${threadId}/comments/${commentId}/reactions`,\n      \"POST\",\n      rest,\n    );\n  };\n\n  public deleteReaction = (options: {\n    threadId: string;\n    commentId: string;\n    emoji: string;\n  }) => {\n    return this.doRequest(\n      `/${options.threadId}/comments/${options.commentId}/reactions/${options.emoji}`,\n      \"DELETE\",\n    );\n  };\n}\n","import { v4 } from \"uuid\";\nimport * as Y from \"yjs\";\nimport { CommentBody, CommentData, ThreadData } from \"../../types.js\";\nimport { ThreadStoreAuth } from \"../ThreadStoreAuth.js\";\nimport { YjsThreadStoreBase } from \"./YjsThreadStoreBase.js\";\nimport {\n  commentToYMap,\n  threadToYMap,\n  yMapToComment,\n  yMapToThread,\n} from \"./yjsHelpers.js\";\n\n/**\n * This is a Yjs-based implementation of the ThreadStore interface.\n *\n * It reads and writes thread / comments information directly to the underlying Yjs Document.\n *\n * @important While this is the easiest to add to your app, there are two challenges:\n * - The user needs to be able to write to the Yjs document to store the information.\n *   So a user without write access to the Yjs document cannot leave any comments.\n * - Even with write access, the operations are not secure. Unless your Yjs server\n *   guards against malicious operations, it's technically possible for one user to make changes to another user's comments, etc.\n *   (even though these options are not visible in the UI, a malicious user can make unauthorized changes to the underlying Yjs document)\n */\nexport class YjsThreadStore extends YjsThreadStoreBase {\n  constructor(\n    private readonly userId: string,\n    threadsYMap: Y.Map<any>,\n    auth: ThreadStoreAuth,\n  ) {\n    super(threadsYMap, auth);\n  }\n\n  private transact = <T, R>(\n    fn: (options: T) => R,\n  ): ((options: T) => Promise<R>) => {\n    return async (options: T) => {\n      return this.threadsYMap.doc!.transact(() => {\n        return fn(options);\n      });\n    };\n  };\n\n  public createThread = this.transact(\n    (options: {\n      initialComment: {\n        body: CommentBody;\n        metadata?: any;\n      };\n      metadata?: any;\n    }) => {\n      if (!this.auth.canCreateThread()) {\n        throw new Error(\"Not authorized\");\n      }\n\n      const date = new Date();\n\n      const comment: CommentData = {\n        type: \"comment\",\n        id: v4(),\n        userId: this.userId,\n        createdAt: date,\n        updatedAt: date,\n        reactions: [],\n        metadata: options.initialComment.metadata,\n        body: options.initialComment.body,\n      };\n\n      const thread: ThreadData = {\n        type: \"thread\",\n        id: v4(),\n        createdAt: date,\n        updatedAt: date,\n        comments: [comment],\n        resolved: false,\n        metadata: options.metadata,\n      };\n\n      this.threadsYMap.set(thread.id, threadToYMap(thread));\n\n      return thread;\n    },\n  );\n\n  // YjsThreadStore does not support addThreadToDocument\n  public addThreadToDocument = undefined;\n\n  public addComment = this.transact(\n    (options: {\n      comment: {\n        body: CommentBody;\n        metadata?: any;\n      };\n      threadId: string;\n    }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      if (!this.auth.canAddComment(yMapToThread(yThread))) {\n        throw new Error(\"Not authorized\");\n      }\n\n      const date = new Date();\n      const comment: CommentData = {\n        type: \"comment\",\n        id: v4(),\n        userId: this.userId,\n        createdAt: date,\n        updatedAt: date,\n        deletedAt: undefined,\n        reactions: [],\n        metadata: options.comment.metadata,\n        body: options.comment.body,\n      };\n\n      (yThread.get(\"comments\") as Y.Array<Y.Map<any>>).push([\n        commentToYMap(comment),\n      ]);\n\n      yThread.set(\"updatedAt\", new Date().getTime());\n      return comment;\n    },\n  );\n\n  public updateComment = this.transact(\n    (options: {\n      comment: {\n        body: CommentBody;\n        metadata?: any;\n      };\n      threadId: string;\n      commentId: string;\n    }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      const yCommentIndex = yArrayFindIndex(\n        yThread.get(\"comments\"),\n        (comment) => comment.get(\"id\") === options.commentId,\n      );\n\n      if (yCommentIndex === -1) {\n        throw new Error(\"Comment not found\");\n      }\n\n      const yComment = yThread.get(\"comments\").get(yCommentIndex);\n\n      if (!this.auth.canUpdateComment(yMapToComment(yComment))) {\n        throw new Error(\"Not authorized\");\n      }\n\n      yComment.set(\"body\", options.comment.body);\n      yComment.set(\"updatedAt\", new Date().getTime());\n      yComment.set(\"metadata\", options.comment.metadata);\n    },\n  );\n\n  public deleteComment = this.transact(\n    (options: {\n      threadId: string;\n      commentId: string;\n      softDelete?: boolean;\n    }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      const yCommentIndex = yArrayFindIndex(\n        yThread.get(\"comments\"),\n        (comment) => comment.get(\"id\") === options.commentId,\n      );\n\n      if (yCommentIndex === -1) {\n        throw new Error(\"Comment not found\");\n      }\n\n      const yComment = yThread.get(\"comments\").get(yCommentIndex);\n\n      if (!this.auth.canDeleteComment(yMapToComment(yComment))) {\n        throw new Error(\"Not authorized\");\n      }\n\n      if (yComment.get(\"deletedAt\")) {\n        throw new Error(\"Comment already deleted\");\n      }\n\n      if (options.softDelete) {\n        yComment.set(\"deletedAt\", new Date().getTime());\n        yComment.set(\"body\", undefined);\n      } else {\n        yThread.get(\"comments\").delete(yCommentIndex);\n      }\n\n      if (\n        (yThread.get(\"comments\") as Y.Array<any>)\n          .toArray()\n          .every((comment) => comment.get(\"deletedAt\"))\n      ) {\n        // all comments deleted\n        if (options.softDelete) {\n          yThread.set(\"deletedAt\", new Date().getTime());\n        } else {\n          this.threadsYMap.delete(options.threadId);\n        }\n      }\n\n      yThread.set(\"updatedAt\", new Date().getTime());\n    },\n  );\n\n  public deleteThread = this.transact((options: { threadId: string }) => {\n    if (\n      !this.auth.canDeleteThread(\n        yMapToThread(this.threadsYMap.get(options.threadId)),\n      )\n    ) {\n      throw new Error(\"Not authorized\");\n    }\n\n    this.threadsYMap.delete(options.threadId);\n  });\n\n  public resolveThread = this.transact((options: { threadId: string }) => {\n    const yThread = this.threadsYMap.get(options.threadId);\n    if (!yThread) {\n      throw new Error(\"Thread not found\");\n    }\n\n    if (!this.auth.canResolveThread(yMapToThread(yThread))) {\n      throw new Error(\"Not authorized\");\n    }\n\n    yThread.set(\"resolved\", true);\n    yThread.set(\"resolvedUpdatedAt\", new Date().getTime());\n    yThread.set(\"resolvedBy\", this.userId);\n  });\n\n  public unresolveThread = this.transact((options: { threadId: string }) => {\n    const yThread = this.threadsYMap.get(options.threadId);\n    if (!yThread) {\n      throw new Error(\"Thread not found\");\n    }\n\n    if (!this.auth.canUnresolveThread(yMapToThread(yThread))) {\n      throw new Error(\"Not authorized\");\n    }\n\n    yThread.set(\"resolved\", false);\n    yThread.set(\"resolvedUpdatedAt\", new Date().getTime());\n  });\n\n  public addReaction = this.transact(\n    (options: { threadId: string; commentId: string; emoji: string }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      const yCommentIndex = yArrayFindIndex(\n        yThread.get(\"comments\"),\n        (comment) => comment.get(\"id\") === options.commentId,\n      );\n\n      if (yCommentIndex === -1) {\n        throw new Error(\"Comment not found\");\n      }\n\n      const yComment = yThread.get(\"comments\").get(yCommentIndex);\n\n      if (!this.auth.canAddReaction(yMapToComment(yComment), options.emoji)) {\n        throw new Error(\"Not authorized\");\n      }\n\n      const date = new Date();\n\n      const key = `${this.userId}-${options.emoji}`;\n\n      const reactionsByUser = yComment.get(\"reactionsByUser\");\n\n      if (reactionsByUser.has(key)) {\n        // already exists\n        return;\n      } else {\n        const reaction = new Y.Map();\n        reaction.set(\"emoji\", options.emoji);\n        reaction.set(\"createdAt\", date.getTime());\n        reaction.set(\"userId\", this.userId);\n        reactionsByUser.set(key, reaction);\n      }\n    },\n  );\n\n  public deleteReaction = this.transact(\n    (options: { threadId: string; commentId: string; emoji: string }) => {\n      const yThread = this.threadsYMap.get(options.threadId);\n      if (!yThread) {\n        throw new Error(\"Thread not found\");\n      }\n\n      const yCommentIndex = yArrayFindIndex(\n        yThread.get(\"comments\"),\n        (comment) => comment.get(\"id\") === options.commentId,\n      );\n\n      if (yCommentIndex === -1) {\n        throw new Error(\"Comment not found\");\n      }\n\n      const yComment = yThread.get(\"comments\").get(yCommentIndex);\n\n      if (\n        !this.auth.canDeleteReaction(yMapToComment(yComment), options.emoji)\n      ) {\n        throw new Error(\"Not authorized\");\n      }\n\n      const key = `${this.userId}-${options.emoji}`;\n\n      const reactionsByUser = yComment.get(\"reactionsByUser\");\n\n      reactionsByUser.delete(key);\n    },\n  );\n}\n\nfunction yArrayFindIndex(\n  yArray: Y.Array<any>,\n  predicate: (item: any) => boolean,\n) {\n  for (let i = 0; i < yArray.length; i++) {\n    if (predicate(yArray.get(i))) {\n      return i;\n    }\n  }\n  return -1;\n}\n"],"names":["ThreadStoreAuth","DefaultThreadStoreAuth","userId","role","_thread","comment","emoji","reaction","ThreadStore","auth","__publicField","TiptapThreadStore","provider","options","thread","reactions","_a","existingReaction","r","_b","_c","threadId","cb","newCb","commentToYMap","yMap","Y","threadToYMap","commentsArray","yMapToReaction","yMapToReactions","acc","yMapToComment","yMapToThread","YjsThreadStoreBase","threadsYMap","yThread","threadMap","id","observer","RESTYjsThreadStore","BASE_URL","headers","path","method","body","response","rest","commentId","YjsThreadStore","fn","date","v4","yCommentIndex","yArrayFindIndex","yComment","key","reactionsByUser","yArray","predicate","i"],"mappings":"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"}