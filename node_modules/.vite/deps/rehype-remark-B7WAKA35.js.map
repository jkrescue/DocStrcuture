{
  "version": 3,
  "sources": ["../../rehype-minify-whitespace/lib/index.js", "../../hast-util-to-mdast/lib/handlers/a.js", "../../hast-util-to-mdast/lib/handlers/base.js", "../../hast-util-to-mdast/lib/handlers/blockquote.js", "../../hast-util-to-mdast/lib/handlers/br.js", "../../unist-util-find-after/lib/index.js", "../../hast-util-to-text/lib/index.js", "../../trim-trailing-lines/index.js", "../../hast-util-to-mdast/lib/handlers/code.js", "../../hast-util-to-mdast/lib/handlers/comment.js", "../../hast-util-to-mdast/lib/handlers/del.js", "../../hast-util-to-mdast/lib/util/list-items-spread.js", "../../hast-util-to-mdast/lib/handlers/dl.js", "../../hast-util-to-mdast/lib/handlers/em.js", "../../hast-util-to-mdast/lib/util/drop-surrounding-breaks.js", "../../hast-util-to-mdast/lib/handlers/heading.js", "../../hast-util-to-mdast/lib/handlers/hr.js", "../../hast-util-to-mdast/lib/handlers/iframe.js", "../../hast-util-to-mdast/lib/handlers/img.js", "../../hast-util-to-mdast/lib/handlers/inline-code.js", "../../hast-util-to-mdast/lib/util/find-selected-options.js", "../../hast-util-to-mdast/lib/handlers/input.js", "../../hast-util-to-mdast/lib/handlers/li.js", "../../hast-util-to-mdast/lib/handlers/list.js", "../../hast-util-to-mdast/lib/util/wrap.js", "../../hast-util-to-mdast/lib/handlers/media.js", "../../hast-util-to-mdast/lib/handlers/p.js", "../../hast-util-to-mdast/lib/handlers/q.js", "../../hast-util-to-mdast/lib/handlers/root.js", "../../hast-util-to-mdast/lib/handlers/select.js", "../../hast-util-to-mdast/lib/handlers/strong.js", "../../hast-util-to-mdast/lib/handlers/table-cell.js", "../../hast-util-to-mdast/lib/handlers/table-row.js", "../../hast-util-to-mdast/lib/handlers/table.js", "../../hast-util-to-mdast/lib/handlers/text.js", "../../hast-util-to-mdast/lib/handlers/textarea.js", "../../hast-util-to-mdast/lib/handlers/wbr.js", "../../hast-util-to-mdast/lib/handlers/index.js", "../../hast-util-to-mdast/lib/state.js", "../../hast-util-to-mdast/lib/index.js", "../../rehype-remark/lib/index.js"],
  "sourcesContent": ["/**\n * @import {Options} from 'hast-util-minify-whitespace'\n * @import {Root} from 'hast'\n */\n\nimport {minifyWhitespace} from 'hast-util-minify-whitespace'\n\n/**\n * Minify whitespace.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeMinifyWhitespace(options) {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    minifyWhitespace(tree, options)\n  }\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link}\n *   mdast node.\n */\nexport function a(state, node) {\n  const properties = node.properties || {}\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    url: state.resolve(String(properties.href || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {undefined}\n *   Nothing.\n */\nexport function base(state, node) {\n  if (!state.baseFound) {\n    state.frozenBaseUrl =\n      String((node.properties && node.properties.href) || '') || undefined\n    state.baseFound = true\n  }\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Blockquote} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Blockquote}\n *   mdast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Blockquote} */\n  const result = {type: 'blockquote', children: state.toFlow(state.all(node))}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Break} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Break}\n *   mdast node.\n */\nexport function br(state, node) {\n  /** @type {Break} */\n  const result = {type: 'break'}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n *\n * @param parent\n *   Parent node.\n * @param index\n *   Child node or index.\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @returns\n *   A child (matching `test`, if given) or `undefined`.\n */\nexport const findAfter =\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  (\n    /**\n     * @param {UnistParent} parent\n     * @param {UnistNode | number} index\n     * @param {Test} [test]\n     * @returns {UnistNode | undefined}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return undefined\n    }\n  )\n", "/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast-util-is-element').TestFunction} TestFunction\n */\n\n/**\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\n *   Valid and useful whitespace values (from CSS).\n *\n * @typedef {0 | 1 | 2} BreakNumber\n *   Specific break:\n *\n *   *   `0` — space\n *   *   `1` — line ending\n *   *   `2` — blank line\n *\n * @typedef {'\\n'} BreakForce\n *   Forced break.\n *\n * @typedef {boolean} BreakValue\n *   Whether there was a break.\n *\n * @typedef {BreakNumber | BreakValue | undefined} BreakBefore\n *   Any value for a break before.\n *\n * @typedef {BreakForce | BreakNumber | BreakValue | undefined} BreakAfter\n *   Any value for a break after.\n *\n * @typedef CollectionInfo\n *   Info on current collection.\n * @property {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @property {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @property {Whitespace} whitespace\n *   Current whitespace setting.\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace | null | undefined} [whitespace='normal']\n *   Initial CSS whitespace setting to use (default: `'normal'`).\n */\n\nimport {findAfter} from 'unist-util-find-after'\nimport {convertElement} from 'hast-util-is-element'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst cell = convertElement(isCell)\nconst p = convertElement('p')\nconst row = convertElement('tr')\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'li', // Lists (as `display: list-item`)\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Get the plain-text value of a node.\n *\n * ###### Algorithm\n *\n * *   if `tree` is a comment, returns its `value`\n * *   if `tree` is a text, applies normal whitespace collapsing to its\n *     `value`, as defined by the CSS Text spec\n * *   if `tree` is a root or element, applies an algorithm similar to the\n *     `innerText` getter as defined by HTML\n *\n * ###### Notes\n *\n * > 👉 **Note**: the algorithm acts as if `tree` is being rendered, and as if\n * > we’re a CSS-supporting user agent, with scripting enabled.\n *\n * *   if `tree` is an element that is not displayed (such as a `head`), we’ll\n *     still use the `innerText` algorithm instead of switching to `textContent`\n * *   if descendants of `tree` are elements that are not displayed, they are\n *     ignored\n * *   CSS is not considered, except for the default user agent style sheet\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\n *     with Chinese, Japanese, or Yi writing systems\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\n *\n * @param {Nodes} tree\n *   Tree to turn into text.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `tree`.\n */\nexport function toText(tree, options) {\n  const options_ = options || {}\n  const children = 'children' in tree ? tree.children : []\n  const block = blockOrCaption(tree)\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options_.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n\n  /** @type {Array<BreakNumber | string>} */\n  const results = []\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (tree.type === 'text' || tree.type === 'comment') {\n    results.push(\n      ...collectText(tree, {\n        whitespace,\n        breakBefore: true,\n        breakAfter: true\n      })\n    )\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  let index = -1\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results.push(\n      ...renderedTextCollection(\n        children[index],\n        // @ts-expect-error: `tree` is a parent if we’re here.\n        tree,\n        {\n          whitespace,\n          breakBefore: index ? undefined : block,\n          breakAfter:\n            index < children.length - 1 ? br(children[index + 1]) : block\n        }\n      )\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {number | undefined} */\n  let count\n\n  index = -1\n\n  while (++index < results.length) {\n    const value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count !== undefined && count > -1) {\n        result.push('\\n'.repeat(count) || ' ')\n      }\n\n      count = -1\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/multipage/dom.html#rendered-text-collection-steps>\n *\n * @param {Nodes} node\n * @param {Parents} parent\n * @param {CollectionInfo} info\n * @returns {Array<BreakNumber | string>}\n */\nfunction renderedTextCollection(node, parent, info) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, info)\n  }\n\n  if (node.type === 'text') {\n    return info.whitespace === 'normal'\n      ? collectText(node, info)\n      : collectPreText(node)\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {Element} node\n *   Element node.\n * @param {Parents} parent\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n */\nfunction collectElement(node, parent, info) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, info)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array<BreakNumber | string>} */\n  let items = []\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  /** @type {BreakNumber | undefined} */\n  let prefix\n  /** @type {BreakForce | BreakNumber | undefined} */\n  let suffix\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (\n    row(node) &&\n    // @ts-expect-error: something up with types of parents.\n    findAfter(parent, node, row)\n  ) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      renderedTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  if (\n    cell(node) &&\n    // @ts-expect-error: something up with types of parents.\n    findAfter(parent, node, cell)\n  ) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {Comment | Text} node\n *   Text node.\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectText(node, info) {\n  const value = String(node.value)\n  /** @type {Array<string>} */\n  const lines = []\n  /** @type {Array<BreakNumber | string>} */\n  const result = []\n  let start = 0\n\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start\n\n    const match = searchLineFeeds.exec(value)\n    const end = match && 'index' in match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // […] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        start === 0 ? info.breakBefore : true,\n        end === value.length ? info.breakAfter : true\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  let index = -1\n  /** @type {BreakNumber | undefined} */\n  let join\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x20_0b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x20_0b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = undefined\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (typeof join === 'number') result.push(join)\n      result.push(lines[index])\n      join = 0\n    } else if (index === 0 || index === lines.length - 1) {\n      // If this line is empty, and it’s the first or last, add a space.\n      // Note that this function is only called in normal whitespace, so we\n      // don’t worry about `pre`.\n      result.push(0)\n    }\n  }\n\n  return result\n}\n\n/**\n * Collect a text node as “pre” whitespace.\n *\n * @param {Text} node\n *   Text node.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectPreText(node) {\n  return [String(node.value)]\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n *   Value to collapse.\n * @param {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @param {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @returns {string}\n *   Result.\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  /** @type {number | undefined} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    const match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * Figure out the whitespace of a node.\n *\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Nodes} node\n *   Node (typically `Element`).\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Whitespace}\n *   Applied whitespace.\n */\nfunction inferWhitespace(node, info) {\n  if (node.type === 'element') {\n    const properties = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return properties.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return properties.noWrap ? 'nowrap' : info.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return info.whitespace\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {properties: {hidden: true}}}\n */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {tagName: 'td' | 'th'}}\n */\nfunction isCell(node) {\n  return node.tagName === 'td' || node.tagName === 'th'\n}\n\n/**\n * @type {TestFunction}\n */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n", "/**\n * Remove final line endings from `value`\n *\n * @param {unknown} value\n *   Value with trailing line endings, coerced to string.\n * @return {string}\n *   Value without trailing line endings.\n */\nexport function trimTrailingLines(value) {\n  const input = String(value)\n  let end = input.length\n\n  while (end > 0) {\n    const code = input.codePointAt(end - 1)\n    if (code !== undefined && (code === 10 || code === 13)) {\n      end--\n    } else {\n      break\n    }\n  }\n\n  return input.slice(0, end)\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Code} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {trimTrailingLines} from 'trim-trailing-lines'\n\nconst prefix = 'language-'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Code}\n *   mdast node.\n */\nexport function code(state, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<number | string> | undefined} */\n  let classList\n  /** @type {string | undefined} */\n  let lang\n\n  if (node.tagName === 'pre') {\n    while (++index < children.length) {\n      const child = children[index]\n\n      if (\n        child.type === 'element' &&\n        child.tagName === 'code' &&\n        child.properties &&\n        child.properties.className &&\n        Array.isArray(child.properties.className)\n      ) {\n        classList = child.properties.className\n        break\n      }\n    }\n  }\n\n  if (classList) {\n    index = -1\n\n    while (++index < classList.length) {\n      if (String(classList[index]).slice(0, prefix.length) === prefix) {\n        lang = String(classList[index]).slice(prefix.length)\n        break\n      }\n    }\n  }\n\n  /** @type {Code} */\n  const result = {\n    type: 'code',\n    lang: lang || null,\n    meta: null,\n    value: trimTrailingLines(toText(node))\n  }\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Comment} from 'hast'\n * @import {Html} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Comment>} node\n *   hast element to transform.\n * @returns {Html}\n *   mdast node.\n */\nexport function comment(state, node) {\n  /** @type {Html} */\n  const result = {\n    type: 'html',\n    value: '<!--' + node.value + '-->'\n  }\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Delete, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Delete}\n *   mdast node.\n */\nexport function del(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n  /** @type {Delete} */\n  const result = {type: 'delete', children}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {ListContent} from 'mdast'\n */\n\n/**\n * Infer whether list items are spread.\n *\n * @param {Readonly<Array<Readonly<ListContent>>>} children\n *   List items.\n * @returns {boolean}\n *   Whether one or more list items are spread.\n */\nexport function listItemsSpread(children) {\n  let index = -1\n\n  if (children.length > 1) {\n    while (++index < children.length) {\n      if (children[index].spread) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {ElementContent, Element} from 'hast'\n * @import {BlockContent, DefinitionContent, ListContent, ListItem, List} from 'mdast'\n */\n\n/**\n * @typedef Group\n *   Title/definition group.\n * @property {Array<Element>} titles\n *   One or more titles.\n * @property {Array<ElementContent>} definitions\n *   One or more definitions.\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List | undefined}\n *   mdast node.\n */\nexport function dl(state, node) {\n  /** @type {Array<ElementContent>} */\n  const clean = []\n  /** @type {Array<Group>} */\n  const groups = []\n  let index = -1\n\n  // Unwrap `<div>`s\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element' && child.tagName === 'div') {\n      clean.push(...child.children)\n    } else {\n      clean.push(child)\n    }\n  }\n\n  /** @type {Group} */\n  let group = {definitions: [], titles: []}\n  index = -1\n\n  // Group titles and definitions.\n  while (++index < clean.length) {\n    const child = clean[index]\n\n    if (child.type === 'element' && child.tagName === 'dt') {\n      const previous = clean[index - 1]\n\n      if (\n        previous &&\n        previous.type === 'element' &&\n        previous.tagName === 'dd'\n      ) {\n        groups.push(group)\n        group = {definitions: [], titles: []}\n      }\n\n      group.titles.push(child)\n    } else {\n      group.definitions.push(child)\n    }\n  }\n\n  groups.push(group)\n\n  // Create items.\n  index = -1\n  /** @type {Array<ListContent>} */\n  const content = []\n\n  while (++index < groups.length) {\n    const result = [\n      ...handle(state, groups[index].titles),\n      ...handle(state, groups[index].definitions)\n    ]\n\n    if (result.length > 0) {\n      content.push({\n        type: 'listItem',\n        spread: result.length > 1,\n        checked: null,\n        children: result\n      })\n    }\n  }\n\n  // Create a list if there are items.\n  if (content.length > 0) {\n    /** @type {List} */\n    const result = {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(content),\n      children: content\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Array<ElementContent>} children\n *   hast element children to transform.\n * @returns {Array<BlockContent | DefinitionContent>}\n *   mdast nodes.\n */\nfunction handle(state, children) {\n  const nodes = state.all({type: 'root', children})\n  const listItems = state.toSpecificContent(nodes, create)\n\n  if (listItems.length === 0) {\n    return []\n  }\n\n  if (listItems.length === 1) {\n    return listItems[0].children\n  }\n\n  return [\n    {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(listItems),\n      children: listItems\n    }\n  ]\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Emphasis, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Emphasis}\n *   mdast node.\n */\nexport function em(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Emphasis} */\n  const result = {type: 'emphasis', children}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {Nodes} from 'mdast'\n */\n\n/**\n * Drop trailing initial and final `br`s.\n *\n * @template {Nodes} Node\n *   Node type.\n * @param {Array<Node>} nodes\n *   List of nodes.\n * @returns {Array<Node>}\n *   List of nodes w/o `break`s.\n */\nexport function dropSurroundingBreaks(nodes) {\n  let start = 0\n  let end = nodes.length\n\n  while (start < end && nodes[start].type === 'break') start++\n  while (end > start && nodes[end - 1].type === 'break') end--\n\n  return start === 0 && end === nodes.length ? nodes : nodes.slice(start, end)\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Heading, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Heading}\n *   mdast node.\n */\nexport function heading(state, node) {\n  const depth = /** @type {Heading['depth']} */ (\n    /* c8 ignore next */\n    Number(node.tagName.charAt(1)) || 1\n  )\n  const children = dropSurroundingBreaks(\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  /** @type {Heading} */\n  const result = {type: 'heading', depth, children}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ThematicBreak} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ThematicBreak}\n *   mdast node.\n */\nexport function hr(state, node) {\n  /** @type {ThematicBreak} */\n  const result = {type: 'thematicBreak'}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link | undefined}\n *   mdast node.\n */\nexport function iframe(state, node) {\n  const properties = node.properties || {}\n  const source = String(properties.src || '')\n  const title = String(properties.title || '')\n\n  // Only create a link if there is a title.\n  // We can’t use the content of the frame because conforming HTML parsers treat\n  // it as text, whereas legacy parsers treat it as HTML, so it will likely\n  // contain tags that will show up in text.\n  if (source && title) {\n    /** @type {Link} */\n    const result = {\n      type: 'link',\n      title: null,\n      url: state.resolve(source),\n      children: [{type: 'text', value: title}]\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Image}\n *   mdast node.\n */\nexport function img(state, node) {\n  const properties = node.properties || {}\n\n  /** @type {Image} */\n  const result = {\n    type: 'image',\n    url: state.resolve(String(properties.src || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    alt: properties.alt ? String(properties.alt) : ''\n  }\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {InlineCode} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {InlineCode}\n *   mdast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {InlineCode} */\n  const result = {type: 'inlineCode', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {Element, Properties} from 'hast'\n */\n\n/**\n * @typedef {[string, Value]} Option\n *   Option, where the item at `0` is the label, the item at `1` the value.\n *\n * @typedef {Array<Option>} Options\n *   List of options.\n *\n * @typedef {string | undefined} Value\n *   `value` field of option.\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {Readonly<Element>} node\n *   hast element to inspect.\n * @param {Properties | undefined} [explicitProperties]\n *   Properties to use, normally taken from `node`, but can be changed.\n * @returns {Options}\n *   Options.\n */\nexport function findSelectedOptions(node, explicitProperties) {\n  /** @type {Array<Element>} */\n  const selectedOptions = []\n  /** @type {Options} */\n  const values = []\n  const properties = explicitProperties || node.properties || {}\n  const options = findOptions(node)\n  const size =\n    Math.min(Number.parseInt(String(properties.size), 10), 0) ||\n    (properties.multiple ? 4 : 1)\n  let index = -1\n\n  while (++index < options.length) {\n    const option = options[index]\n\n    if (option && option.properties && option.properties.selected) {\n      selectedOptions.push(option)\n    }\n  }\n\n  const list = selectedOptions.length > 0 ? selectedOptions : options\n  const max = Math.min(list.length, size)\n  index = -1\n\n  while (++index < max) {\n    const option = list[index]\n    const properties = option.properties || {}\n    const content = toText(option)\n    const label = content || String(properties.label || '')\n    const value = String(properties.value || '') || content\n    values.push([value, label === value ? undefined : label])\n  }\n\n  return values\n}\n\n/**\n * @param {Element} node\n *   Parent to find in.\n * @returns {Array<Element>}\n *   Option elements.\n */\nfunction findOptions(node) {\n  /** @type {Array<Element>} */\n  const results = []\n  let index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if ('children' in child && Array.isArray(child.children)) {\n      results.push(...findOptions(child))\n    }\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'option' &&\n      (!child.properties || !child.properties.disabled)\n    ) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, Text} from 'mdast'\n * @import {Options} from '../util/find-selected-options.js'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\nconst defaultChecked = '[x]'\nconst defaultUnchecked = '[ ]'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<Link | Text> | Image | Text | undefined}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function input(state, node) {\n  const properties = node.properties || {}\n  const value = String(properties.value || properties.placeholder || '')\n\n  if (\n    properties.disabled ||\n    properties.type === 'hidden' ||\n    properties.type === 'file'\n  ) {\n    return\n  }\n\n  if (properties.type === 'checkbox' || properties.type === 'radio') {\n    /** @type {Text} */\n    const result = {\n      type: 'text',\n      value: properties.checked\n        ? state.options.checked || defaultChecked\n        : state.options.unchecked || defaultUnchecked\n    }\n    state.patch(node, result)\n    return result\n  }\n\n  if (properties.type === 'image') {\n    const alt = properties.alt || value\n\n    if (alt) {\n      /** @type {Image} */\n      const result = {\n        type: 'image',\n        url: state.resolve(String(properties.src || '') || null),\n        title: String(properties.title || '') || null,\n        alt: String(alt)\n      }\n      state.patch(node, result)\n      return result\n    }\n\n    return\n  }\n\n  /** @type {Options} */\n  let values = []\n\n  if (value) {\n    values = [[value, undefined]]\n  } else if (\n    // `list` is not supported on these types:\n    properties.type !== 'button' &&\n    properties.type !== 'file' &&\n    properties.type !== 'password' &&\n    properties.type !== 'reset' &&\n    properties.type !== 'submit' &&\n    properties.list\n  ) {\n    const list = String(properties.list)\n    const datalist = state.elementById.get(list)\n\n    if (datalist && datalist.tagName === 'datalist') {\n      values = findSelectedOptions(datalist, properties)\n    }\n  }\n\n  if (values.length === 0) {\n    return\n  }\n\n  // Hide password value.\n  if (properties.type === 'password') {\n    // Passwords don’t support `list`.\n    values[0] = ['•'.repeat(values[0][0].length), undefined]\n  }\n\n  if (properties.type === 'email' || properties.type === 'url') {\n    /** @type {Array<Link | Text>} */\n    const results = []\n    let index = -1\n\n    while (++index < values.length) {\n      const value = state.resolve(values[index][0])\n      /** @type {Link} */\n      const result = {\n        type: 'link',\n        title: null,\n        url: properties.type === 'email' ? 'mailto:' + value : value,\n        children: [{type: 'text', value: values[index][1] || value}]\n      }\n\n      results.push(result)\n\n      if (index !== values.length - 1) {\n        results.push({type: 'text', value: ', '})\n      }\n    }\n\n    return results\n  }\n\n  /** @type {Array<string>} */\n  const texts = []\n  let index = -1\n\n  while (++index < values.length) {\n    texts.push(\n      values[index][1]\n        ? values[index][1] + ' (' + values[index][0] + ')'\n        : values[index][0]\n    )\n  }\n\n  /** @type {Text} */\n  const result = {type: 'text', value: texts.join(', ')}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem} from 'mdast'\n */\n\n/**\n * @typedef ExtractResult\n *   Result of extracting a leading checkbox.\n * @property {Element | undefined} checkbox\n *   The checkbox that was removed, if any.\n * @property {Element} rest\n *   If there was a leading checkbox, a deep clone of the node w/o the leading\n *   checkbox; otherwise a reference to the given, untouched, node.\n */\n\nimport {phrasing} from 'hast-util-phrasing'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ListItem}\n *   mdast node.\n */\nexport function li(state, node) {\n  // If the list item starts with a checkbox, remove the checkbox and mark the\n  // list item as a GFM task list item.\n  const {rest, checkbox} = extractLeadingCheckbox(node)\n  const checked = checkbox ? Boolean(checkbox.properties.checked) : null\n  const spread = spreadout(rest)\n  const children = state.toFlow(state.all(rest))\n\n  /** @type {ListItem} */\n  const result = {type: 'listItem', spread, checked, children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Check if an element should spread out.\n *\n * The reason to spread out a markdown list item is primarily whether writing\n * the equivalent in markdown, would yield a spread out item.\n *\n * A spread out item results in `<p>` and `</p>` tags.\n * Otherwise, the phrasing would be output directly.\n * We can check for that: if there’s a `<p>` element, spread it out.\n *\n * But what if there are no paragraphs?\n * In that case, we can also assume that if two “block” things were written in\n * an item, that it is spread out, because blocks are typically joined by blank\n * lines, which also means a spread item.\n *\n * Lastly, because in HTML things can be wrapped in a `<div>` or similar, we\n * delve into non-phrasing elements here to figure out if they themselves\n * contain paragraphs or 2 or more flow non-phrasing elements.\n *\n * @param {Readonly<Element>} node\n * @returns {boolean}\n */\nfunction spreadout(node) {\n  let index = -1\n  let seenFlow = false\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element') {\n      if (phrasing(child)) continue\n\n      if (child.tagName === 'p' || seenFlow || spreadout(child)) {\n        return true\n      }\n\n      seenFlow = true\n    }\n  }\n\n  return false\n}\n\n/**\n * Extract a leading checkbox from a list item.\n *\n * If there was a leading checkbox, makes a deep clone of the node w/o the\n * leading checkbox; otherwise a reference to the given, untouched, node is\n * given back.\n *\n * So for example:\n *\n * ```html\n * <li><input type=\"checkbox\">Text</li>\n * ```\n *\n * …becomes:\n *\n * ```html\n * <li>Text</li>\n * ```\n *\n * ```html\n * <li><p><input type=\"checkbox\">Text</p></li>\n * ```\n *\n * …becomes:\n *\n * ```html\n * <li><p>Text</p></li>\n * ```\n *\n * @param {Readonly<Element>} node\n * @returns {ExtractResult}\n */\nfunction extractLeadingCheckbox(node) {\n  const head = node.children[0]\n\n  if (\n    head &&\n    head.type === 'element' &&\n    head.tagName === 'input' &&\n    head.properties &&\n    (head.properties.type === 'checkbox' || head.properties.type === 'radio')\n  ) {\n    const rest = {...node, children: node.children.slice(1)}\n    return {checkbox: head, rest}\n  }\n\n  // The checkbox may be nested in another element.\n  // If the first element has children, look for a leading checkbox inside it.\n  //\n  // This only handles nesting in `<p>` elements, which is most common.\n  // It’s possible a leading checkbox might be nested in other types of flow or\n  // phrasing elements (and *deeply* nested, which is not possible with `<p>`).\n  // Limiting things to `<p>` elements keeps this simpler for now.\n  if (head && head.type === 'element' && head.tagName === 'p') {\n    const {checkbox, rest: restHead} = extractLeadingCheckbox(head)\n\n    if (checkbox) {\n      const rest = {...node, children: [restHead, ...node.children.slice(1)]}\n      return {checkbox, rest}\n    }\n  }\n\n  return {checkbox: undefined, rest: node}\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem, List} from 'mdast'\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List}\n *   mdast node.\n */\nexport function list(state, node) {\n  const ordered = node.tagName === 'ol'\n  const children = state.toSpecificContent(state.all(node), create)\n  /** @type {number | null} */\n  let start = null\n\n  if (ordered) {\n    start =\n      node.properties && node.properties.start\n        ? Number.parseInt(String(node.properties.start), 10)\n        : 1\n  }\n\n  /** @type {List} */\n  const result = {\n    type: 'list',\n    ordered,\n    start,\n    spread: listItemsSpread(children),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n", "/**\n * @import {} from 'mdast-util-to-hast'\n * @import {\n *   BlockContent,\n *   Delete,\n *   Link,\n *   Nodes,\n *   Paragraph,\n *   Parents,\n *   PhrasingContent,\n *   RootContent\n * } from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {phrasing as hastPhrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {phrasing as mdastPhrasing} from 'mdast-util-phrasing'\nimport {dropSurroundingBreaks} from './drop-surrounding-breaks.js'\n\n/**\n * Check if there are phrasing mdast nodes.\n *\n * This is needed if a fragment is given, which could just be a sentence, and\n * doesn’t need a wrapper paragraph.\n *\n * @param {Array<Nodes>} nodes\n * @returns {boolean}\n */\nexport function wrapNeeded(nodes) {\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Wrap runs of phrasing content into paragraphs, leaving the non-phrasing\n * content as-is.\n *\n * @param {Array<RootContent>} nodes\n *   Content.\n * @returns {Array<BlockContent>}\n *   Content where phrasing is wrapped in paragraphs.\n */\nexport function wrap(nodes) {\n  return runs(nodes, onphrasing, function (d) {\n    return d\n  })\n\n  /**\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<Paragraph>}\n   */\n  function onphrasing(nodes) {\n    return nodes.every(function (d) {\n      return d.type === 'text' ? whitespace(d.value) : false\n    })\n      ? []\n      : [{type: 'paragraph', children: dropSurroundingBreaks(nodes)}]\n  }\n}\n\n/**\n * @param {Delete | Link} node\n * @returns {Array<BlockContent>}\n */\nfunction split(node) {\n  return runs(node.children, onphrasing, onnonphrasing)\n\n  /**\n   * Use `parent`, put the phrasing run inside it.\n   *\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<BlockContent>}\n   */\n  function onphrasing(nodes) {\n    const newParent = cloneWithoutChildren(node)\n    newParent.children = nodes\n    // @ts-expect-error Assume fine.\n    return [newParent]\n  }\n\n  /**\n   * Use `child`, add `parent` as its first child, put the original children\n   * into `parent`.\n   * If `child` is not a parent, `parent` will not be added.\n   *\n   * @param {BlockContent} child\n   * @returns {BlockContent}\n   */\n  function onnonphrasing(child) {\n    if ('children' in child && 'children' in node) {\n      const newParent = cloneWithoutChildren(node)\n      const newChild = cloneWithoutChildren(child)\n      // @ts-expect-error Assume fine.\n      newParent.children = child.children\n      // @ts-expect-error Assume fine.\n      newChild.children.push(newParent)\n      return newChild\n    }\n\n    return {...child}\n  }\n}\n\n/**\n * Wrap all runs of mdast phrasing content in `paragraph` nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of input nodes.\n * @param {(nodes: Array<PhrasingContent>) => Array<BlockContent>} onphrasing\n *   Turn phrasing content into block content.\n * @param {(node: BlockContent) => BlockContent} onnonphrasing\n *   Map block content (defaults to keeping them as-is).\n * @returns {Array<BlockContent>}\n */\nfunction runs(nodes, onphrasing, onnonphrasing) {\n  const flattened = flatten(nodes)\n  /** @type {Array<BlockContent>} */\n  const result = []\n  /** @type {Array<PhrasingContent>} */\n  let queue = []\n  let index = -1\n\n  while (++index < flattened.length) {\n    const node = flattened[index]\n\n    if (phrasing(node)) {\n      queue.push(node)\n    } else {\n      if (queue.length > 0) {\n        result.push(...onphrasing(queue))\n        queue = []\n      }\n\n      // @ts-expect-error Assume non-phrasing.\n      result.push(onnonphrasing(node))\n    }\n  }\n\n  if (queue.length > 0) {\n    result.push(...onphrasing(queue))\n    queue = []\n  }\n\n  return result\n}\n\n/**\n * Flatten a list of nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of nodes, will unravel `delete` and `link`.\n * @returns {Array<RootContent>}\n *   Unraveled nodes.\n */\nfunction flatten(nodes) {\n  /** @type {Array<RootContent>} */\n  const flattened = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    // Straddling: some elements are *weird*.\n    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.\n    // See: <https://html.spec.whatwg.org/#paragraphs>.\n    // Paragraphs are the weirdest of them all.\n    // See the straddling fixture for more info!\n    // `ins` is ignored in mdast, so we don’t need to worry about that.\n    // `map` maps to its content, so we don’t need to worry about that either.\n    // `del` maps to `delete` and `a` to `link`, so we do handle those.\n    // What we’ll do is split `node` over each of its children.\n    if (\n      (node.type === 'delete' || node.type === 'link') &&\n      wrapNeeded(node.children)\n    ) {\n      flattened.push(...split(node))\n    } else {\n      flattened.push(node)\n    }\n  }\n\n  return flattened\n}\n\n/**\n * Check if an mdast node is phrasing.\n *\n * Also supports checking embedded hast fields.\n *\n * @param {Nodes} node\n *   mdast node to check.\n * @returns {node is PhrasingContent}\n *   Whether `node` is phrasing content (includes nodes with `hName` fields\n *   set to phrasing hast element names).\n */\nfunction phrasing(node) {\n  const tagName = node.data && node.data.hName\n  return tagName\n    ? hastPhrasing({type: 'element', tagName, properties: {}, children: []})\n    : mdastPhrasing(node)\n}\n\n/**\n * @template {Parents} ParentType\n *   Parent type.\n * @param {ParentType} node\n *   Node to clone.\n * @returns {ParentType}\n *   Cloned node, without children.\n */\nfunction cloneWithoutChildren(node) {\n  return structuredClone({...node, children: []})\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, PhrasingContent, RootContent as MdastRootContent, Root} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\nimport {EXIT, visit} from 'unist-util-visit'\nimport {wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent> | Link}\n *   mdast node.\n */\nexport function media(state, node) {\n  const properties = node.properties || {}\n  const poster = node.tagName === 'video' ? String(properties.poster || '') : ''\n  let source = String(properties.src || '')\n  let index = -1\n  let linkInFallbackContent = false\n  let nodes = state.all(node)\n\n  /** @type {Root} */\n  const fragment = {type: 'root', children: nodes}\n\n  visit(fragment, function (node) {\n    if (node.type === 'link') {\n      linkInFallbackContent = true\n      return EXIT\n    }\n  })\n\n  // If the content links to something, or if it’s not phrasing…\n  if (linkInFallbackContent || wrapNeeded(nodes)) {\n    return nodes\n  }\n\n  // Find the source.\n  while (!source && ++index < node.children.length) {\n    const child = node.children[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'source' &&\n      child.properties\n    ) {\n      source = String(child.properties.src || '')\n    }\n  }\n\n  // If there’s a poster defined on the video, create an image.\n  if (poster) {\n    /** @type {Image} */\n    const image = {\n      type: 'image',\n      title: null,\n      url: state.resolve(poster),\n      alt: toString(nodes)\n    }\n    state.patch(node, image)\n    nodes = [image]\n  }\n\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (nodes)\n\n  // Link to the media resource.\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: properties.title ? String(properties.title) : null,\n    url: state.resolve(source),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Paragraph, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Paragraph | undefined}\n *   mdast node.\n */\nexport function p(state, node) {\n  const children = dropSurroundingBreaks(\n    // Allow potentially “invalid” nodes, they might be unknown.\n    // We also support straddling later.\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  if (children.length > 0) {\n    /** @type {Paragraph} */\n    const result = {type: 'paragraph', children}\n    state.patch(node, result)\n    return result\n  }\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RootContent as MdastRootContent} from 'mdast'\n */\n\nconst defaultQuotes = ['\"']\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent>}\n *   mdast nodes.\n */\nexport function q(state, node) {\n  const quotes = state.options.quotes || defaultQuotes\n\n  state.qNesting++\n  const contents = state.all(node)\n  state.qNesting--\n\n  const quote = quotes[state.qNesting % quotes.length]\n  const head = contents[0]\n  const tail = contents[contents.length - 1]\n  const open = quote.charAt(0)\n  const close = quote.length > 1 ? quote.charAt(1) : quote\n\n  if (head && head.type === 'text') {\n    head.value = open + head.value\n  } else {\n    contents.unshift({type: 'text', value: open})\n  }\n\n  if (tail && tail.type === 'text') {\n    tail.value += close\n  } else {\n    contents.push({type: 'text', value: close})\n  }\n\n  return contents\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Root as HastRoot} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n */\n\nimport {wrap, wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastRoot>} node\n *   hast root to transform.\n * @returns {MdastRoot}\n *   mdast node.\n */\nexport function root(state, node) {\n  let children = state.all(node)\n\n  if (state.options.document || wrapNeeded(children)) {\n    children = wrap(children)\n  }\n\n  /** @type {MdastRoot} */\n  const result = {type: 'root', children}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text | undefined}\n *   mdast node.\n */\nexport function select(state, node) {\n  const values = findSelectedOptions(node)\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n\n  while (++index < values.length) {\n    const value = values[index]\n    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])\n  }\n\n  if (results.length > 0) {\n    /** @type {Text} */\n    const result = {type: 'text', value: results.join(', ')}\n    state.patch(node, result)\n    return result\n  }\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, Strong} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Strong}\n *   mdast node.\n */\nexport function strong(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Strong} */\n  const result = {type: 'strong', children}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, TableCell} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableCell}\n *   mdast node.\n */\nexport function tableCell(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {TableCell} */\n  const result = {type: 'tableCell', children}\n  state.patch(node, result)\n\n  if (node.properties) {\n    const rowSpan = node.properties.rowSpan\n    const colSpan = node.properties.colSpan\n\n    if (rowSpan || colSpan) {\n      const data = /** @type {Record<string, unknown>} */ (\n        result.data || (result.data = {})\n      )\n      if (rowSpan) data.hastUtilToMdastTemporaryRowSpan = rowSpan\n      if (colSpan) data.hastUtilToMdastTemporaryColSpan = colSpan\n    }\n  }\n\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RowContent, TableRow} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableRow}\n *   mdast node.\n */\nexport function tableRow(state, node) {\n  const children = state.toSpecificContent(state.all(node), create)\n\n  /** @type {TableRow} */\n  const result = {type: 'tableRow', children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {RowContent}\n */\nfunction create() {\n  return {type: 'tableCell', children: []}\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {AlignType, RowContent, TableContent, Table, Text} from 'mdast'\n */\n\n/**\n * @typedef Info\n *   Inferred info on a table.\n * @property {Array<AlignType>} align\n *   Alignment.\n * @property {boolean} headless\n *   Whether a `thead` is missing.\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {SKIP, visit} from 'unist-util-visit'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Table | Text}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function table(state, node) {\n  // Ignore nested tables.\n  if (state.inTable) {\n    /** @type {Text} */\n    const result = {type: 'text', value: toText(node)}\n    state.patch(node, result)\n    return result\n  }\n\n  state.inTable = true\n\n  const {align, headless} = inspect(node)\n  const rows = state.toSpecificContent(state.all(node), createRow)\n\n  // Add an empty header row.\n  if (headless) {\n    rows.unshift(createRow())\n  }\n\n  let rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const row = rows[rowIndex]\n    const cells = state.toSpecificContent(row.children, createCell)\n    row.children = cells\n  }\n\n  let columns = 1\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = -1\n\n    while (++cellIndex < cells.length) {\n      const cell = cells[cellIndex]\n\n      if (cell.data) {\n        const data = /** @type {Record<string, unknown>} */ (cell.data)\n        const colSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryColSpan), 10) || 1\n        const rowSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryRowSpan), 10) || 1\n\n        if (colSpan > 1 || rowSpan > 1) {\n          let otherRowIndex = rowIndex - 1\n\n          while (++otherRowIndex < rowIndex + rowSpan) {\n            let colIndex = cellIndex - 1\n\n            while (++colIndex < cellIndex + colSpan) {\n              if (!rows[otherRowIndex]) {\n                // Don’t add rows that don’t exist.\n                // Browsers don’t render them either.\n                break\n              }\n\n              /** @type {Array<RowContent>} */\n              const newCells = []\n\n              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {\n                newCells.push({type: 'tableCell', children: []})\n              }\n\n              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)\n            }\n          }\n        }\n\n        // Clean the data fields.\n        if ('hastUtilToMdastTemporaryColSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryColSpan\n        if ('hastUtilToMdastTemporaryRowSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryRowSpan\n        if (Object.keys(cell.data).length === 0) delete cell.data\n      }\n    }\n\n    if (cells.length > columns) columns = cells.length\n  }\n\n  // Add extra empty cells.\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = cells.length - 1\n    while (++cellIndex < columns) {\n      cells.push({type: 'tableCell', children: []})\n    }\n  }\n\n  let alignIndex = align.length - 1\n  while (++alignIndex < columns) {\n    align.push(null)\n  }\n\n  state.inTable = false\n\n  /** @type {Table} */\n  const result = {type: 'table', align, children: rows}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Infer whether the HTML table has a head and how it aligns.\n *\n * @param {Readonly<Element>} node\n *   Table element to check.\n * @returns {Info}\n *   Info.\n */\nfunction inspect(node) {\n  /** @type {Info} */\n  const info = {align: [null], headless: true}\n  let rowIndex = 0\n  let cellIndex = 0\n\n  visit(node, function (child) {\n    if (child.type === 'element') {\n      // Don’t enter nested tables.\n      if (child.tagName === 'table' && node !== child) {\n        return SKIP\n      }\n\n      if (\n        (child.tagName === 'th' || child.tagName === 'td') &&\n        child.properties\n      ) {\n        if (!info.align[cellIndex]) {\n          const value = String(child.properties.align || '') || null\n\n          if (\n            value === 'center' ||\n            value === 'left' ||\n            value === 'right' ||\n            value === null\n          ) {\n            info.align[cellIndex] = value\n          }\n        }\n\n        // If there is a `th` in the first row, assume there is a header row.\n        if (info.headless && rowIndex < 2 && child.tagName === 'th') {\n          info.headless = false\n        }\n\n        cellIndex++\n      }\n      // If there is a `thead`, assume there is a header row.\n      else if (child.tagName === 'thead') {\n        info.headless = false\n      } else if (child.tagName === 'tr') {\n        rowIndex++\n        cellIndex = 0\n      }\n    }\n  })\n\n  return info\n}\n\n/**\n * @returns {RowContent}\n */\nfunction createCell() {\n  return {type: 'tableCell', children: []}\n}\n\n/**\n * @returns {TableContent}\n */\nfunction createRow() {\n  return {type: 'tableRow', children: []}\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Text as HastText} from 'hast'\n * @import {Text as MdastText} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastText>} node\n *   hast element to transform.\n * @returns {MdastText}\n *   mdast node.\n */\nexport function text(state, node) {\n  /** @type {MdastText} */\n  const result = {type: 'text', value: node.value}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function textarea(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function wbr(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: '\\u200B'}\n  state.patch(node, result)\n  return result\n}\n", "/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Parents} from 'hast'\n */\n\nimport {a} from './a.js'\nimport {base} from './base.js'\nimport {blockquote} from './blockquote.js'\nimport {br} from './br.js'\nimport {code} from './code.js'\nimport {comment} from './comment.js'\nimport {del} from './del.js'\nimport {dl} from './dl.js'\nimport {em} from './em.js'\nimport {heading} from './heading.js'\nimport {hr} from './hr.js'\nimport {iframe} from './iframe.js'\nimport {img} from './img.js'\nimport {inlineCode} from './inline-code.js'\nimport {input} from './input.js'\nimport {li} from './li.js'\nimport {list} from './list.js'\nimport {media} from './media.js'\nimport {p} from './p.js'\nimport {q} from './q.js'\nimport {root} from './root.js'\nimport {select} from './select.js'\nimport {strong} from './strong.js'\nimport {tableCell} from './table-cell.js'\nimport {tableRow} from './table-row.js'\nimport {table} from './table.js'\nimport {text} from './text.js'\nimport {textarea} from './textarea.js'\nimport {wbr} from './wbr.js'\n\n/**\n * Default handlers for nodes.\n *\n * Each key is a node type, each value is a `NodeHandler`.\n */\nexport const nodeHandlers = {\n  comment,\n  doctype: ignore,\n  root,\n  text\n}\n\n/**\n * Default handlers for elements.\n *\n * Each key is an element name, each value is a `Handler`.\n */\nexport const handlers = {\n  // Ignore:\n  applet: ignore,\n  area: ignore,\n  basefont: ignore,\n  bgsound: ignore,\n  caption: ignore,\n  col: ignore,\n  colgroup: ignore,\n  command: ignore,\n  content: ignore,\n  datalist: ignore,\n  dialog: ignore,\n  element: ignore,\n  embed: ignore,\n  frame: ignore,\n  frameset: ignore,\n  isindex: ignore,\n  keygen: ignore,\n  link: ignore,\n  math: ignore,\n  menu: ignore,\n  menuitem: ignore,\n  meta: ignore,\n  nextid: ignore,\n  noembed: ignore,\n  noframes: ignore,\n  optgroup: ignore,\n  option: ignore,\n  param: ignore,\n  script: ignore,\n  shadow: ignore,\n  source: ignore,\n  spacer: ignore,\n  style: ignore,\n  svg: ignore,\n  template: ignore,\n  title: ignore,\n  track: ignore,\n\n  // Use children:\n  abbr: all,\n  acronym: all,\n  bdi: all,\n  bdo: all,\n  big: all,\n  blink: all,\n  button: all,\n  canvas: all,\n  cite: all,\n  data: all,\n  details: all,\n  dfn: all,\n  font: all,\n  ins: all,\n  label: all,\n  map: all,\n  marquee: all,\n  meter: all,\n  nobr: all,\n  noscript: all,\n  object: all,\n  output: all,\n  progress: all,\n  rb: all,\n  rbc: all,\n  rp: all,\n  rt: all,\n  rtc: all,\n  ruby: all,\n  slot: all,\n  small: all,\n  span: all,\n  sup: all,\n  sub: all,\n  tbody: all,\n  tfoot: all,\n  thead: all,\n  time: all,\n\n  // Use children as flow.\n  address: flow,\n  article: flow,\n  aside: flow,\n  body: flow,\n  center: flow,\n  div: flow,\n  fieldset: flow,\n  figcaption: flow,\n  figure: flow,\n  form: flow,\n  footer: flow,\n  header: flow,\n  hgroup: flow,\n  html: flow,\n  legend: flow,\n  main: flow,\n  multicol: flow,\n  nav: flow,\n  picture: flow,\n  section: flow,\n\n  // Handle.\n  a,\n  audio: media,\n  b: strong,\n  base,\n  blockquote,\n  br,\n  code: inlineCode,\n  dir: list,\n  dl,\n  dt: li,\n  dd: li,\n  del,\n  em,\n  h1: heading,\n  h2: heading,\n  h3: heading,\n  h4: heading,\n  h5: heading,\n  h6: heading,\n  hr,\n  i: em,\n  iframe,\n  img,\n  image: img,\n  input,\n  kbd: inlineCode,\n  li,\n  listing: code,\n  mark: em,\n  ol: list,\n  p,\n  plaintext: code,\n  pre: code,\n  q,\n  s: del,\n  samp: inlineCode,\n  select,\n  strike: del,\n  strong,\n  summary: p,\n  table,\n  td: tableCell,\n  textarea,\n  th: tableCell,\n  tr: tableRow,\n  tt: inlineCode,\n  u: em,\n  ul: list,\n  var: inlineCode,\n  video: media,\n  wbr,\n  xmp: code\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction all(state, node) {\n  return state.all(node)\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction flow(state, node) {\n  return state.toFlow(state.all(node))\n}\n\n/**\n * @returns {undefined}\n */\nfunction ignore() {}\n", "/**\n * @import {Element, Nodes, Parents} from 'hast'\n * @import {\n *   BlockContent as MdastBlockContent,\n *   DefinitionContent as MdastDefinitionContent,\n *   Nodes as MdastNodes,\n *   Parents as MdastParents,\n *   RootContent as MdastRootContent\n * } from 'mdast'\n */\n\n/**\n * @typedef {MdastBlockContent | MdastDefinitionContent} MdastFlowContent\n */\n\n/**\n * @callback All\n *   Transform the children of a hast parent to mdast.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n *\n * @callback Handle\n *   Handle a particular element.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Element} element\n *   Element to transform.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback NodeHandle\n *   Handle a particular node.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {any} node\n *   Node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback One\n *   Transform a hast node to mdast.\n * @param {Nodes} node\n *   Expected hast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n *\n * @typedef Options\n *   Configuration.\n * @property {string | null | undefined} [checked='[x]']\n *   Value to use for a checked checkbox or radio input (default: `'[x]'`)\n * @property {boolean | null | undefined} [document]\n *   Whether the given tree represents a complete document (optional).\n *\n *   Applies when the `tree` is a `root` node.\n *   When the tree represents a complete document, then things are wrapped in\n *   paragraphs when needed, and otherwise they’re left as-is.\n *   The default checks for whether there’s mixed content: some phrasing nodes\n *   *and* some non-phrasing nodes.\n * @property {Record<string, Handle | null | undefined> | null | undefined} [handlers]\n *   Object mapping tag names to functions handling the corresponding elements\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {boolean | null | undefined} [newlines=false]\n *   Keep line endings when collapsing whitespace (default: `false`).\n *\n *   The default collapses to a single space.\n * @property {Record<string, NodeHandle | null | undefined> | null | undefined} [nodeHandlers]\n *   Object mapping node types to functions handling the corresponding nodes\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {Array<string> | null | undefined} [quotes=['\"']]\n *   List of quotes to use (default: `['\"']`).\n *\n *   Each value can be one or two characters.\n *   When two, the first character determines the opening quote and the second\n *   the closing quote at that level.\n *   When one, both the opening and closing quote are that character.\n *\n *   The order in which the preferred quotes appear determines which quotes to\n *   use at which level of nesting.\n *   So, to prefer `‘’` at the first level of nesting, and `“”` at the second,\n *   pass `['‘’', '“”']`.\n *   If `<q>`s are nested deeper than the given amount of quotes, the markers\n *   wrap around: a third level of nesting when using `['«»', '‹›']` should\n *   have double guillemets, a fourth single, a fifth double again, etc.\n * @property {string | null | undefined} [unchecked='[ ]']\n *   Value to use for an unchecked checkbox or radio input (default: `'[ ]'`).\n *\n * @callback Patch\n *   Copy a node’s positional info.\n * @param {Nodes} from\n *   hast node to copy from.\n * @param {MdastNodes} to\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback Resolve\n *   Resolve a URL relative to a base.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {All} all\n *   Transform the children of a hast parent to mdast.\n * @property {boolean} baseFound\n *   Whether a `<base>` element was seen.\n * @property {Map<string, Element>} elementById\n *   Elements by their `id`.\n * @property {string | undefined} frozenBaseUrl\n *   `href` of `<base>`, if any.\n * @property {Record<string, Handle>} handlers\n *   Applied element handlers.\n * @property {boolean} inTable\n *   Whether we’re in a table.\n * @property {Record<string, NodeHandle>} nodeHandlers\n *   Applied node handlers.\n * @property {One} one\n *   Transform a hast node to mdast.\n * @property {Options} options\n *   User configuration.\n * @property {Patch} patch\n *   Copy a node’s positional info.\n * @property {number} qNesting\n *   Non-negative finite integer representing how deep we’re in `<q>`s.\n * @property {Resolve} resolve\n *   Resolve a URL relative to a base.\n * @property {ToFlow} toFlow\n *   Transform a list of mdast nodes to flow.\n * @property {<ChildType extends MdastNodes, ParentType extends MdastParents & {'children': Array<ChildType>}>(nodes: Array<MdastRootContent>, build: (() => ParentType)) => Array<ParentType>} toSpecificContent\n *   Turn arbitrary content into a list of a particular node type.\n *\n *   This is useful for example for lists, which must have list items as\n *   content.\n *   in this example, when non-items are found, they will be queued, and\n *   inserted into an adjacent item.\n *   When no actual items exist, one will be made with `build`.\n *\n * @callback ToFlow\n *   Transform a list of mdast nodes to flow.\n * @param {Array<MdastRootContent>} nodes\n *   mdast nodes.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\n\nimport {position} from 'unist-util-position'\nimport {handlers, nodeHandlers} from './handlers/index.js'\nimport {wrap} from './util/wrap.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a state.\n *\n * @param {Readonly<Options>} options\n *   User configuration.\n * @returns {State}\n *   State.\n */\nexport function createState(options) {\n  return {\n    all,\n    baseFound: false,\n    elementById: new Map(),\n    frozenBaseUrl: undefined,\n    handlers: {...handlers, ...options.handlers},\n    inTable: false,\n    nodeHandlers: {...nodeHandlers, ...options.nodeHandlers},\n    one,\n    options,\n    patch,\n    qNesting: 0,\n    resolve,\n    toFlow,\n    toSpecificContent\n  }\n}\n\n/**\n * Transform the children of a hast parent to mdast.\n *\n * You might want to combine this with `toFlow` or `toSpecificContent`.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n */\nfunction all(parent) {\n  const children = parent.children || []\n  /** @type {Array<MdastRootContent>} */\n  const results = []\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    // Content -> content.\n    const result =\n      /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */ (\n        this.one(child, parent)\n      )\n\n    if (Array.isArray(result)) {\n      results.push(...result)\n    } else if (result) {\n      results.push(result)\n    }\n  }\n\n  return results\n}\n\n/**\n * Transform a hast node to mdast.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n */\nfunction one(node, parent) {\n  if (node.type === 'element') {\n    if (node.properties && node.properties.dataMdast === 'ignore') {\n      return\n    }\n\n    if (own.call(this.handlers, node.tagName)) {\n      return this.handlers[node.tagName](this, node, parent) || undefined\n    }\n  } else if (own.call(this.nodeHandlers, node.type)) {\n    return this.nodeHandlers[node.type](this, node, parent) || undefined\n  }\n\n  // Unknown literal.\n  if ('value' in node && typeof node.value === 'string') {\n    /** @type {MdastRootContent} */\n    const result = {type: 'text', value: node.value}\n    this.patch(node, result)\n    return result\n  }\n\n  // Unknown parent.\n  if ('children' in node) {\n    return this.all(node)\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {Nodes} origin\n *   hast node to copy from.\n * @param {MdastNodes} node\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(origin, node) {\n  if (origin.position) node.position = position(origin)\n}\n\n/**\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n */\nfunction resolve(url) {\n  const base = this.frozenBaseUrl\n\n  if (url === null || url === undefined) {\n    return ''\n  }\n\n  if (base) {\n    return String(new URL(url, base))\n  }\n\n  return url\n}\n\n/**\n * Transform a list of mdast nodes to flow.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Array<MdastRootContent>} nodes\n *   Parent.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\nfunction toFlow(nodes) {\n  return wrap(nodes)\n}\n\n/**\n * Turn arbitrary content into a particular node type.\n *\n * This is useful for example for lists, which must have list items as content.\n * in this example, when non-items are found, they will be queued, and\n * inserted into an adjacent item.\n * When no actual items exist, one will be made with `build`.\n *\n * @template {MdastNodes} ChildType\n *   Node type of children.\n * @template {MdastParents & {'children': Array<ChildType>}} ParentType\n *   Node type of parent.\n * @param {Array<MdastRootContent>} nodes\n *   Nodes, which are either `ParentType`, or will be wrapped in one.\n * @param {() => ParentType} build\n *   Build a parent if needed (must have empty `children`).\n * @returns {Array<ParentType>}\n *   List of parents.\n */\nfunction toSpecificContent(nodes, build) {\n  const reference = build()\n  /** @type {Array<ParentType>} */\n  const results = []\n  /** @type {Array<ChildType>} */\n  let queue = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (expectedParent(node)) {\n      if (queue.length > 0) {\n        node.children.unshift(...queue)\n        queue = []\n      }\n\n      results.push(node)\n    } else {\n      // Assume `node` can be a child of `ParentType`.\n      // If we start checking nodes, we’d run into problems with unknown nodes,\n      // which we do want to support.\n      const child = /** @type {ChildType} */ (node)\n      queue.push(child)\n    }\n  }\n\n  if (queue.length > 0) {\n    let node = results[results.length - 1]\n\n    if (!node) {\n      node = build()\n      results.push(node)\n    }\n\n    node.children.push(...queue)\n    queue = []\n  }\n\n  return results\n\n  /**\n   * @param {MdastNodes} node\n   * @returns {node is ParentType}\n   */\n  function expectedParent(node) {\n    return node.type === reference.type\n  }\n}\n", "/**\n * @import {Options} from 'hast-util-to-mdast'\n * @import {Nodes} from 'hast'\n * @import {Nodes as MdastNodes, RootContent as MdastRootContent} from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {visit} from 'unist-util-visit'\nimport {createState} from './state.js'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Transform hast to mdast.\n *\n * @param {Readonly<Nodes>} tree\n *   hast tree to transform.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {MdastNodes}\n *   mdast tree.\n */\nexport function toMdast(tree, options) {\n  // We have to clone, cause we’ll use `rehype-minify-whitespace` on the tree,\n  // which modifies.\n  const cleanTree = structuredClone(tree)\n  const settings = options || emptyOptions\n  const transformWhitespace = rehypeMinifyWhitespace({\n    newlines: settings.newlines === true\n  })\n  const state = createState(settings)\n  /** @type {MdastNodes} */\n  let mdast\n\n  // @ts-expect-error: fine to pass an arbitrary node.\n  transformWhitespace(cleanTree)\n\n  visit(cleanTree, function (node) {\n    if (node && node.type === 'element' && node.properties) {\n      const id = String(node.properties.id || '') || undefined\n\n      if (id && !state.elementById.has(id)) {\n        state.elementById.set(id, node)\n      }\n    }\n  })\n\n  const result = state.one(cleanTree, undefined)\n\n  if (!result) {\n    mdast = {type: 'root', children: []}\n  } else if (Array.isArray(result)) {\n    // Assume content.\n    const children = /** @type {Array<MdastRootContent>} */ (result)\n    mdast = {type: 'root', children}\n  } else {\n    mdast = result\n  }\n\n  // Collapse text nodes, and fix whitespace.\n  //\n  // Most of this is taken care of by `rehype-minify-whitespace`, but\n  // we’re generating some whitespace too, and some nodes are in the end\n  // ignored.\n  // So clean up.\n  visit(mdast, function (node, index, parent) {\n    if (node.type === 'text' && index !== undefined && parent) {\n      const previous = parent.children[index - 1]\n\n      if (previous && previous.type === node.type) {\n        previous.value += node.value\n        parent.children.splice(index, 1)\n\n        if (previous.position && node.position) {\n          previous.position.end = node.position.end\n        }\n\n        // Iterate over the previous node again, to handle its total value.\n        return index - 1\n      }\n\n      node.value = node.value.replace(/[\\t ]*(\\r?\\n|\\r)[\\t ]*/, '$1')\n\n      // We don’t care about other phrasing nodes in between (e.g., `[ asd ]()`),\n      // as there the whitespace matters.\n      if (\n        parent &&\n        (parent.type === 'heading' ||\n          parent.type === 'paragraph' ||\n          parent.type === 'root')\n      ) {\n        if (!index) {\n          node.value = node.value.replace(/^[\\t ]+/, '')\n        }\n\n        if (index === parent.children.length - 1) {\n          node.value = node.value.replace(/[\\t ]+$/, '')\n        }\n      }\n\n      if (!node.value) {\n        parent.children.splice(index, 1)\n        return index\n      }\n    }\n  })\n\n  return mdast\n}\n", "/**\n * @import {Root as HastRoot} from 'hast'\n * @import {Options} from 'hast-util-to-mdast'\n * @import {Root as MdastRoot} from 'mdast'\n * @import {Processor} from 'unified'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @callback TransformBridge\n *   Bridge-mode.\n *\n *   Runs the destination with the new mdast tree.\n *   Discards result.\n * @param {HastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {Promise<undefined>}\n *   Nothing.\n *\n * @callback TransformMutate\n *  Mutate-mode.\n *\n *  Further transformers run on the mdast tree.\n * @param {HastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {MdastRoot}\n *   Tree (mdast).\n */\n\nimport {toMdast} from 'hast-util-to-mdast'\n\n/** @satisfies {Options} */\nconst defaults = {document: true}\n\n/**\n * Turn HTML into markdown.\n *\n * ###### Notes\n *\n * *   if a processor is given, runs the (remark) plugins used on it with an\n *     mdast tree, then discards the result (*bridge mode*)\n * *   otherwise, returns an mdast tree, the plugins used after `rehypeRemark`\n *     are remark plugins (*mutate mode*)\n *\n * > 👉 **Note**: It’s highly unlikely that you want to pass a `processor`.\n *\n * @overload\n * @param {Processor} processor\n * @param {Options | null | undefined} [options]\n * @returns {TransformBridge}\n *\n * @overload\n * @param {Options | null | undefined} [options]\n * @returns {TransformMutate}\n *\n * @overload\n * @param {Options | Processor | null | undefined} [destination]\n * @param {Options | null | undefined} [options]\n * @returns {TransformBridge | TransformMutate}\n *\n * @param {Options | Processor | null | undefined} [destination]\n *   Processor or configuration (optional).\n * @param {Options | null | undefined} [options]\n *   When a processor was given, configuration (optional).\n * @returns {TransformBridge | TransformMutate}\n *   Transform.\n */\nexport default function rehypeRemark(destination, options) {\n  if (destination && 'run' in destination) {\n    /**\n     * @type {TransformBridge}\n     */\n    return async function (tree, file) {\n      const mdastTree = toMdast(tree, {...defaults, ...options})\n      await destination.run(mdastTree, file)\n    }\n  }\n\n  /**\n   * @type {TransformMutate}\n   */\n  return function (tree) {\n    return /** @type {MdastRoot} */ (\n      toMdast(tree, {...defaults, ...destination})\n    )\n  }\n}\n"],
  "mappings": "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",
  "names": ["br", "whitespace", "prefix", "input", "code", "list", "properties", "result", "list", "index", "value", "create", "phrasing", "nodes", "node", "p", "create", "result", "row", "cell", "p", "all", "base"]
}
