{
  "version": 3,
  "sources": ["../../html-whitespace-sensitive-tag-names/lib/index.js", "../../hast-util-format/lib/index.js", "../../rehype-format/lib/index.js"],
  "sourcesContent": ["/**\n * List of HTML tag names that are whitespace sensitive.\n */\nexport const whitespaceSensitiveTagNames = [\n  'pre',\n  'script',\n  'style',\n  'textarea'\n]\n", "/**\n * @import {Nodes, RootContent, Root} from 'hast'\n * @import {BuildVisitor} from 'unist-util-visit-parents'\n * @import {Options, State} from './types.js'\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {minifyWhitespace} from 'hast-util-minify-whitespace'\nimport {phrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Root} tree\n *   Tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport function format(tree, options) {\n  const settings = options || emptyOptions\n\n  /** @type {State} */\n  const state = {\n    blanks: settings.blanks || [],\n    head: false,\n    indentInitial: settings.indentInitial !== false,\n    indent:\n      typeof settings.indent === 'number'\n        ? ' '.repeat(settings.indent)\n        : typeof settings.indent === 'string'\n          ? settings.indent\n          : '  '\n  }\n\n  minifyWhitespace(tree, {newlines: true})\n\n  visitParents(tree, visitor)\n\n  /**\n   * @type {BuildVisitor<Root>}\n   */\n  function visitor(node, parents) {\n    if (!('children' in node)) {\n      return\n    }\n\n    if (node.type === 'element' && node.tagName === 'head') {\n      state.head = true\n    }\n\n    if (state.head && node.type === 'element' && node.tagName === 'body') {\n      state.head = false\n    }\n\n    if (\n      node.type === 'element' &&\n      whitespaceSensitiveTagNames.includes(node.tagName)\n    ) {\n      return SKIP\n    }\n\n    // Don’t indent content of whitespace-sensitive nodes / inlines.\n    if (node.children.length === 0 || !padding(state, node)) {\n      return\n    }\n\n    let level = parents.length\n\n    if (!state.indentInitial) {\n      level--\n    }\n\n    let eol = false\n\n    // Indent newlines in `text`.\n    for (const child of node.children) {\n      if (child.type === 'comment' || child.type === 'text') {\n        if (child.value.includes('\\n')) {\n          eol = true\n        }\n\n        child.value = child.value.replace(\n          / *\\n/g,\n          '$&' + state.indent.repeat(level)\n        )\n      }\n    }\n\n    /** @type {Array<RootContent>} */\n    const result = []\n    /** @type {RootContent | undefined} */\n    let previous\n\n    for (const child of node.children) {\n      if (padding(state, child) || (eol && !previous)) {\n        addBreak(result, level, child)\n        eol = true\n      }\n\n      previous = child\n      result.push(child)\n    }\n\n    if (previous && (eol || padding(state, previous))) {\n      // Ignore trailing whitespace (if that already existed), as we’ll add\n      // properly indented whitespace.\n      if (whitespace(previous)) {\n        result.pop()\n        previous = result[result.length - 1]\n      }\n\n      addBreak(result, level - 1)\n    }\n\n    node.children = result\n  }\n\n  /**\n   * @param {Array<RootContent>} list\n   *   Nodes.\n   * @param {number} level\n   *   Indentation level.\n   * @param {RootContent | undefined} [next]\n   *   Next node.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1]\n    const previous = tail && whitespace(tail) ? list[list.length - 2] : tail\n    const replace =\n      (blank(state, previous) && blank(state, next) ? '\\n\\n' : '\\n') +\n      state.indent.repeat(Math.max(level, 0))\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace\n    } else {\n      list.push({type: 'text', value: replace})\n    }\n  }\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes | undefined} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is a blank.\n */\nfunction blank(state, node) {\n  return Boolean(\n    node &&\n      node.type === 'element' &&\n      state.blanks.length > 0 &&\n      state.blanks.includes(node.tagName)\n  )\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` should be padded.\n */\nfunction padding(state, node) {\n  return (\n    node.type === 'root' ||\n    (node.type === 'element'\n      ? state.head ||\n        node.tagName === 'script' ||\n        embedded(node) ||\n        !phrasing(node)\n      : false)\n  )\n}\n", "/**\n * @import {Options} from 'hast-util-format'\n * @import {Root} from 'hast'\n */\n\nimport {format} from 'hast-util-format'\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeFormat(options) {\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    format(tree, options)\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
