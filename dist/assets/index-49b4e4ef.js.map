{"version":3,"file":"index-49b4e4ef.js","sources":["../../node_modules/micromark-util-sanitize-uri/index.js","../../node_modules/mdast-util-to-hast/lib/handlers/blockquote.js","../../node_modules/mdast-util-to-hast/lib/handlers/break.js","../../node_modules/mdast-util-to-hast/lib/handlers/code.js","../../node_modules/mdast-util-to-hast/lib/handlers/delete.js","../../node_modules/mdast-util-to-hast/lib/handlers/emphasis.js","../../node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js","../../node_modules/mdast-util-to-hast/lib/handlers/heading.js","../../node_modules/mdast-util-to-hast/lib/handlers/html.js","../../node_modules/mdast-util-to-hast/lib/revert.js","../../node_modules/mdast-util-to-hast/lib/handlers/image-reference.js","../../node_modules/mdast-util-to-hast/lib/handlers/image.js","../../node_modules/mdast-util-to-hast/lib/handlers/inline-code.js","../../node_modules/mdast-util-to-hast/lib/handlers/link-reference.js","../../node_modules/mdast-util-to-hast/lib/handlers/link.js","../../node_modules/mdast-util-to-hast/lib/handlers/list-item.js","../../node_modules/mdast-util-to-hast/lib/handlers/list.js","../../node_modules/mdast-util-to-hast/lib/handlers/paragraph.js","../../node_modules/mdast-util-to-hast/lib/handlers/root.js","../../node_modules/mdast-util-to-hast/lib/handlers/strong.js","../../node_modules/mdast-util-to-hast/lib/handlers/table.js","../../node_modules/mdast-util-to-hast/lib/handlers/table-row.js","../../node_modules/mdast-util-to-hast/lib/handlers/table-cell.js","../../node_modules/trim-lines/index.js","../../node_modules/mdast-util-to-hast/lib/handlers/text.js","../../node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js","../../node_modules/mdast-util-to-hast/lib/handlers/index.js","../../node_modules/mdast-util-to-hast/lib/footer.js","../../node_modules/mdast-util-to-hast/lib/state.js","../../node_modules/mdast-util-to-hast/lib/index.js","../../node_modules/remark-rehype/lib/index.js"],"sourcesContent":["import { asciiAlphanumeric } from 'micromark-util-character';\nimport { encode } from 'micromark-util-encode';\n/**\n * Make a value safe for injection as a URL.\n *\n * This encodes unsafe characters with percent-encoding and skips already\n * encoded sequences (see `normalizeUri`).\n * Further unsafe characters are encoded as character references (see\n * `micromark-util-encode`).\n *\n * A regex of allowed protocols can be given, in which case the URL is\n * sanitized.\n * For example, `/^(https?|ircs?|mailto|xmpp)$/i` can be used for `a[href]`, or\n * `/^https?$/i` for `img[src]` (this is what `github.com` allows).\n * If the URL includes an unknown protocol (one not matched by `protocol`, such\n * as a dangerous example, `javascript:`), the value is ignored.\n *\n * @param {string | null | undefined} url\n *   URI to sanitize.\n * @param {RegExp | null | undefined} [protocol]\n *   Allowed protocols.\n * @returns {string}\n *   Sanitized URI.\n */\nexport function sanitizeUri(url, protocol) {\n  const value = encode(normalizeUri(url || ''));\n  if (!protocol) {\n    return value;\n  }\n  const colon = value.indexOf(':');\n  const questionMark = value.indexOf('?');\n  const numberSign = value.indexOf('#');\n  const slash = value.indexOf('/');\n  if (\n  // If there is no protocol, it’s relative.\n  colon < 0 ||\n  // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign ||\n  // It is a protocol, it should be allowed.\n  protocol.test(value.slice(0, colon))) {\n    return value;\n  }\n  return '';\n}\n\n/**\n * Normalize a URL.\n *\n * Encode unsafe characters with percent-encoding, skipping already encoded\n * sequences.\n *\n * @param {string} value\n *   URI to normalize.\n * @returns {string}\n *   Normalized URI.\n */\nexport function normalizeUri(value) {\n  /** @type {Array<string>} */\n  const result = [];\n  let index = -1;\n  let start = 0;\n  let skip = 0;\n  while (++index < value.length) {\n    const code = value.charCodeAt(index);\n    /** @type {string} */\n    let replace = '';\n\n    // A correct percent encoded value.\n    if (code === 37 && asciiAlphanumeric(value.charCodeAt(index + 1)) && asciiAlphanumeric(value.charCodeAt(index + 2))) {\n      skip = 2;\n    }\n    // ASCII.\n    else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code);\n      }\n    }\n    // Astral.\n    else if (code > 55_295 && code < 57_344) {\n      const next = value.charCodeAt(index + 1);\n\n      // A correct surrogate pair.\n      if (code < 56_320 && next > 56_319 && next < 57_344) {\n        replace = String.fromCharCode(code, next);\n        skip = 1;\n      }\n      // Lone surrogate.\n      else {\n        replace = \"\\uFFFD\";\n      }\n    }\n    // Unicode.\n    else {\n      replace = String.fromCharCode(code);\n    }\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace));\n      start = index + skip + 1;\n      replace = '';\n    }\n    if (skip) {\n      index += skip;\n      skip = 0;\n    }\n  }\n  return result.join('') + value.slice(start);\n}","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `blockquote` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Blockquote} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'blockquote',\n    properties: {},\n    children: state.wrap(state.all(node), true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `break` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Break} node\n *   mdast node.\n * @returns {Array<Element | Text>}\n *   hast element content.\n */\nexport function hardBreak(state, node) {\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'br', properties: {}, children: []}\n  state.patch(node, result)\n  return [state.applyData(node, result), {type: 'text', value: '\\n'}]\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `code` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Code} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function code(state, node) {\n  const value = node.value ? node.value + '\\n' : ''\n  /** @type {Properties} */\n  const properties = {}\n\n  if (node.lang) {\n    properties.className = ['language-' + node.lang]\n  }\n\n  // Create `<code>`.\n  /** @type {Element} */\n  let result = {\n    type: 'element',\n    tagName: 'code',\n    properties,\n    children: [{type: 'text', value}]\n  }\n\n  if (node.meta) {\n    result.data = {meta: node.meta}\n  }\n\n  state.patch(node, result)\n  result = state.applyData(node, result)\n\n  // Create `<pre>`.\n  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Delete} Delete\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `delete` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Delete} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strikethrough(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'del',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `emphasis` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Emphasis} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function emphasis(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'em',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').FootnoteReference} FootnoteReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `footnoteReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {FootnoteReference} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function footnoteReference(state, node) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const id = String(node.identifier).toUpperCase()\n  const safeId = normalizeUri(id.toLowerCase())\n  const index = state.footnoteOrder.indexOf(id)\n  /** @type {number} */\n  let counter\n\n  let reuseCounter = state.footnoteCounts.get(id)\n\n  if (reuseCounter === undefined) {\n    reuseCounter = 0\n    state.footnoteOrder.push(id)\n    counter = state.footnoteOrder.length\n  } else {\n    counter = index + 1\n  }\n\n  reuseCounter += 1\n  state.footnoteCounts.set(id, reuseCounter)\n\n  /** @type {Element} */\n  const link = {\n    type: 'element',\n    tagName: 'a',\n    properties: {\n      href: '#' + clobberPrefix + 'fn-' + safeId,\n      id:\n        clobberPrefix +\n        'fnref-' +\n        safeId +\n        (reuseCounter > 1 ? '-' + reuseCounter : ''),\n      dataFootnoteRef: true,\n      ariaDescribedBy: ['footnote-label']\n    },\n    children: [{type: 'text', value: String(counter)}]\n  }\n  state.patch(node, link)\n\n  /** @type {Element} */\n  const sup = {\n    type: 'element',\n    tagName: 'sup',\n    properties: {},\n    children: [link]\n  }\n  state.patch(node, sup)\n  return state.applyData(node, sup)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `heading` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Heading} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function heading(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'h' + node.depth,\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Html} Html\n * @typedef {import('../state.js').State} State\n * @typedef {import('../../index.js').Raw} Raw\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise\n * nothing).\n *\n * @param {State} state\n *   Info passed around.\n * @param {Html} node\n *   mdast node.\n * @returns {Element | Raw | undefined}\n *   hast node.\n */\nexport function html(state, node) {\n  if (state.options.allowDangerousHtml) {\n    /** @type {Raw} */\n    const result = {type: 'raw', value: node.value}\n    state.patch(node, result)\n    return state.applyData(node, result)\n  }\n\n  return undefined\n}\n","/**\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('mdast').Nodes} Nodes\n * @typedef {import('mdast').Reference} Reference\n *\n * @typedef {import('./state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Return the content of a reference without definition as plain text.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Extract<Nodes, Reference>} node\n *   Reference node (image, link).\n * @returns {Array<ElementContent>}\n *   hast content.\n */\nexport function revert(state, node) {\n  const subtype = node.referenceType\n  let suffix = ']'\n\n  if (subtype === 'collapsed') {\n    suffix += '[]'\n  } else if (subtype === 'full') {\n    suffix += '[' + (node.label || node.identifier) + ']'\n  }\n\n  if (node.type === 'imageReference') {\n    return [{type: 'text', value: '![' + node.alt + suffix}]\n  }\n\n  const contents = state.all(node)\n  const head = contents[0]\n\n  if (head && head.type === 'text') {\n    head.value = '[' + head.value\n  } else {\n    contents.unshift({type: 'text', value: '['})\n  }\n\n  const tail = contents[contents.length - 1]\n\n  if (tail && tail.type === 'text') {\n    tail.value += suffix\n  } else {\n    contents.push({type: 'text', value: suffix})\n  }\n\n  return contents\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `imageReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ImageReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function imageReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const definition = state.definitionById.get(id)\n\n  if (!definition) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(definition.url || ''), alt: node.alt}\n\n  if (definition.title !== null && definition.title !== undefined) {\n    properties.title = definition.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `image` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Image} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function image(state, node) {\n  /** @type {Properties} */\n  const properties = {src: normalizeUri(node.url)}\n\n  if (node.alt !== null && node.alt !== undefined) {\n    properties.alt = node.alt\n  }\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'img', properties, children: []}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Text} Text\n * @typedef {import('mdast').InlineCode} InlineCode\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `inlineCode` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {InlineCode} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {Text} */\n  const text = {type: 'text', value: node.value.replace(/\\r?\\n|\\r/g, ' ')}\n  state.patch(node, text)\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'code',\n    properties: {},\n    children: [text]\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\nimport {revert} from '../revert.js'\n\n/**\n * Turn an mdast `linkReference` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {LinkReference} node\n *   mdast node.\n * @returns {Array<ElementContent> | ElementContent}\n *   hast node.\n */\nexport function linkReference(state, node) {\n  const id = String(node.identifier).toUpperCase()\n  const definition = state.definitionById.get(id)\n\n  if (!definition) {\n    return revert(state, node)\n  }\n\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(definition.url || '')}\n\n  if (definition.title !== null && definition.title !== undefined) {\n    properties.title = definition.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../state.js').State} State\n */\n\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Turn an mdast `link` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Link} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function link(state, node) {\n  /** @type {Properties} */\n  const properties = {href: normalizeUri(node.url)}\n\n  if (node.title !== null && node.title !== undefined) {\n    properties.title = node.title\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'a',\n    properties,\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').ListItem} ListItem\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `listItem` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ListItem} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function listItem(state, node, parent) {\n  const results = state.all(node)\n  const loose = parent ? listLoose(parent) : listItemLoose(node)\n  /** @type {Properties} */\n  const properties = {}\n  /** @type {Array<ElementContent>} */\n  const children = []\n\n  if (typeof node.checked === 'boolean') {\n    const head = results[0]\n    /** @type {Element} */\n    let paragraph\n\n    if (head && head.type === 'element' && head.tagName === 'p') {\n      paragraph = head\n    } else {\n      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []}\n      results.unshift(paragraph)\n    }\n\n    if (paragraph.children.length > 0) {\n      paragraph.children.unshift({type: 'text', value: ' '})\n    }\n\n    paragraph.children.unshift({\n      type: 'element',\n      tagName: 'input',\n      properties: {type: 'checkbox', checked: node.checked, disabled: true},\n      children: []\n    })\n\n    // According to github-markdown-css, this class hides bullet.\n    // See: <https://github.com/sindresorhus/github-markdown-css>.\n    properties.className = ['task-list-item']\n  }\n\n  let index = -1\n\n  while (++index < results.length) {\n    const child = results[index]\n\n    // Add eols before nodes, except if this is a loose, first paragraph.\n    if (\n      loose ||\n      index !== 0 ||\n      child.type !== 'element' ||\n      child.tagName !== 'p'\n    ) {\n      children.push({type: 'text', value: '\\n'})\n    }\n\n    if (child.type === 'element' && child.tagName === 'p' && !loose) {\n      children.push(...child.children)\n    } else {\n      children.push(child)\n    }\n  }\n\n  const tail = results[results.length - 1]\n\n  // Add a final eol.\n  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {\n    children.push({type: 'text', value: '\\n'})\n  }\n\n  /** @type {Element} */\n  const result = {type: 'element', tagName: 'li', properties, children}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * @param {Parents} node\n * @return {Boolean}\n */\nfunction listLoose(node) {\n  let loose = false\n  if (node.type === 'list') {\n    loose = node.spread || false\n    const children = node.children\n    let index = -1\n\n    while (!loose && ++index < children.length) {\n      loose = listItemLoose(children[index])\n    }\n  }\n\n  return loose\n}\n\n/**\n * @param {ListItem} node\n * @return {Boolean}\n */\nfunction listItemLoose(node) {\n  const spread = node.spread\n\n  return spread === null || spread === undefined\n    ? node.children.length > 1\n    : spread\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').List} List\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `list` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {List} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function list(state, node) {\n  /** @type {Properties} */\n  const properties = {}\n  const results = state.all(node)\n  let index = -1\n\n  if (typeof node.start === 'number' && node.start !== 1) {\n    properties.start = node.start\n  }\n\n  // Like GitHub, add a class for custom styling.\n  while (++index < results.length) {\n    const child = results[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'li' &&\n      child.properties &&\n      Array.isArray(child.properties.className) &&\n      child.properties.className.includes('task-list-item')\n    ) {\n      properties.className = ['contains-task-list']\n      break\n    }\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: node.ordered ? 'ol' : 'ul',\n    properties,\n    children: state.wrap(results, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `paragraph` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Paragraph} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function paragraph(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'p',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Parents} HastParents\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('mdast').Root} MdastRoot\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `root` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastRoot} node\n *   mdast node.\n * @returns {HastParents}\n *   hast node.\n */\nexport function root(state, node) {\n  /** @type {HastRoot} */\n  const result = {type: 'root', children: state.wrap(state.all(node))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `strong` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Strong} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function strong(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'strong',\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').Table} Table\n * @typedef {import('../state.js').State} State\n */\n\nimport {pointEnd, pointStart} from 'unist-util-position'\n\n/**\n * Turn an mdast `table` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {Table} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function table(state, node) {\n  const rows = state.all(node)\n  const firstRow = rows.shift()\n  /** @type {Array<Element>} */\n  const tableContent = []\n\n  if (firstRow) {\n    /** @type {Element} */\n    const head = {\n      type: 'element',\n      tagName: 'thead',\n      properties: {},\n      children: state.wrap([firstRow], true)\n    }\n    state.patch(node.children[0], head)\n    tableContent.push(head)\n  }\n\n  if (rows.length > 0) {\n    /** @type {Element} */\n    const body = {\n      type: 'element',\n      tagName: 'tbody',\n      properties: {},\n      children: state.wrap(rows, true)\n    }\n\n    const start = pointStart(node.children[1])\n    const end = pointEnd(node.children[node.children.length - 1])\n    if (start && end) body.position = {start, end}\n    tableContent.push(body)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'table',\n    properties: {},\n    children: state.wrap(tableContent, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('mdast').Parents} Parents\n * @typedef {import('mdast').TableRow} TableRow\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableRow` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableRow} node\n *   mdast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Element}\n *   hast node.\n */\nexport function tableRow(state, node, parent) {\n  const siblings = parent ? parent.children : undefined\n  // Generate a body row when without parent.\n  const rowIndex = siblings ? siblings.indexOf(node) : 1\n  const tagName = rowIndex === 0 ? 'th' : 'td'\n  // To do: option to use `style`?\n  const align = parent && parent.type === 'table' ? parent.align : undefined\n  const length = align ? align.length : node.children.length\n  let cellIndex = -1\n  /** @type {Array<ElementContent>} */\n  const cells = []\n\n  while (++cellIndex < length) {\n    // Note: can also be undefined.\n    const cell = node.children[cellIndex]\n    /** @type {Properties} */\n    const properties = {}\n    const alignValue = align ? align[cellIndex] : undefined\n\n    if (alignValue) {\n      properties.align = alignValue\n    }\n\n    /** @type {Element} */\n    let result = {type: 'element', tagName, properties, children: []}\n\n    if (cell) {\n      result.children = state.all(cell)\n      state.patch(cell, result)\n      result = state.applyData(cell, result)\n    }\n\n    cells.push(result)\n  }\n\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'tr',\n    properties: {},\n    children: state.wrap(cells, true)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').TableCell} TableCell\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `tableCell` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {TableCell} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function tableCell(state, node) {\n  // Note: this function is normally not called: see `table-row` for how rows\n  // and their cells are compiled.\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'td', // Assume body cell.\n    properties: {},\n    children: state.all(node)\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","const tab = 9 /* `\\t` */\nconst space = 32 /* ` ` */\n\n/**\n * Remove initial and final spaces and tabs at the line breaks in `value`.\n * Does not trim initial and final spaces and tabs of the value itself.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Trimmed value.\n */\nexport function trimLines(value) {\n  const source = String(value)\n  const search = /\\r?\\n|\\r/g\n  let match = search.exec(source)\n  let last = 0\n  /** @type {Array<string>} */\n  const lines = []\n\n  while (match) {\n    lines.push(\n      trimLine(source.slice(last, match.index), last > 0, true),\n      match[0]\n    )\n\n    last = match.index + match[0].length\n    match = search.exec(source)\n  }\n\n  lines.push(trimLine(source.slice(last), last > 0, false))\n\n  return lines.join('')\n}\n\n/**\n * @param {string} value\n *   Line to trim.\n * @param {boolean} start\n *   Whether to trim the start of the line.\n * @param {boolean} end\n *   Whether to trim the end of the line.\n * @returns {string}\n *   Trimmed line.\n */\nfunction trimLine(value, start, end) {\n  let startIndex = 0\n  let endIndex = value.length\n\n  if (start) {\n    let code = value.codePointAt(startIndex)\n\n    while (code === tab || code === space) {\n      startIndex++\n      code = value.codePointAt(startIndex)\n    }\n  }\n\n  if (end) {\n    let code = value.codePointAt(endIndex - 1)\n\n    while (code === tab || code === space) {\n      endIndex--\n      code = value.codePointAt(endIndex - 1)\n    }\n  }\n\n  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Text} HastText\n * @typedef {import('mdast').Text} MdastText\n * @typedef {import('../state.js').State} State\n */\n\nimport {trimLines} from 'trim-lines'\n\n/**\n * Turn an mdast `text` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastText} node\n *   mdast node.\n * @returns {HastElement | HastText}\n *   hast node.\n */\nexport function text(state, node) {\n  /** @type {HastText} */\n  const result = {type: 'text', value: trimLines(String(node.value))}\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../state.js').State} State\n */\n\n// Make VS Code show references to the above types.\n''\n\n/**\n * Turn an mdast `thematicBreak` node into hast.\n *\n * @param {State} state\n *   Info passed around.\n * @param {ThematicBreak} node\n *   mdast node.\n * @returns {Element}\n *   hast node.\n */\nexport function thematicBreak(state, node) {\n  /** @type {Element} */\n  const result = {\n    type: 'element',\n    tagName: 'hr',\n    properties: {},\n    children: []\n  }\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n","import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {strikethrough} from './delete.js'\nimport {emphasis} from './emphasis.js'\nimport {footnoteReference} from './footnote-reference.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {imageReference} from './image-reference.js'\nimport {image} from './image.js'\nimport {inlineCode} from './inline-code.js'\nimport {linkReference} from './link-reference.js'\nimport {link} from './link.js'\nimport {listItem} from './list-item.js'\nimport {list} from './list.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {table} from './table.js'\nimport {tableRow} from './table-row.js'\nimport {tableCell} from './table-cell.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default handlers for nodes.\n *\n * @satisfies {import('../state.js').Handlers}\n */\nexport const handlers = {\n  blockquote,\n  break: hardBreak,\n  code,\n  delete: strikethrough,\n  emphasis,\n  footnoteReference,\n  heading,\n  html,\n  imageReference,\n  image,\n  inlineCode,\n  linkReference,\n  link,\n  listItem,\n  list,\n  paragraph,\n  // @ts-expect-error: root is different, but hard to type.\n  root,\n  strong,\n  table,\n  tableCell,\n  tableRow,\n  text,\n  thematicBreak,\n  toml: ignore,\n  yaml: ignore,\n  definition: ignore,\n  footnoteDefinition: ignore\n}\n\n// Return nothing for nodes that are ignored.\nfunction ignore() {\n  return undefined\n}\n","/**\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').ElementContent} ElementContent\n *\n * @typedef {import('./state.js').State} State\n */\n\n/**\n * @callback FootnoteBackContentTemplate\n *   Generate content for the backreference dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent> | ElementContent | string}\n *   Content for the backreference when linking back from definitions to their\n *   reference.\n *\n * @callback FootnoteBackLabelTemplate\n *   Generate a back label dynamically.\n *\n *   For the following markdown:\n *\n *   ```markdown\n *   Alpha[^micromark], bravo[^micromark], and charlie[^remark].\n *\n *   [^remark]: things about remark\n *   [^micromark]: things about micromark\n *   ```\n *\n *   This function will be called with:\n *\n *   *  `0` and `0` for the backreference from `things about micromark` to\n *      `alpha`, as it is the first used definition, and the first call to it\n *   *  `0` and `1` for the backreference from `things about micromark` to\n *      `bravo`, as it is the first used definition, and the second call to it\n *   *  `1` and `0` for the backreference from `things about remark` to\n *      `charlie`, as it is the second used definition\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Back label to use when linking back from definitions to their reference.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {normalizeUri} from 'micromark-util-sanitize-uri'\n\n/**\n * Generate the default content that GitHub uses on backreferences.\n *\n * @param {number} _\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {Array<ElementContent>}\n *   Content.\n */\nexport function defaultFootnoteBackContent(_, rereferenceIndex) {\n  /** @type {Array<ElementContent>} */\n  const result = [{type: 'text', value: '↩'}]\n\n  if (rereferenceIndex > 1) {\n    result.push({\n      type: 'element',\n      tagName: 'sup',\n      properties: {},\n      children: [{type: 'text', value: String(rereferenceIndex)}]\n    })\n  }\n\n  return result\n}\n\n/**\n * Generate the default label that GitHub uses on backreferences.\n *\n * @param {number} referenceIndex\n *   Index of the definition in the order that they are first referenced,\n *   0-indexed.\n * @param {number} rereferenceIndex\n *   Index of calls to the same definition, 0-indexed.\n * @returns {string}\n *   Label.\n */\nexport function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n  return (\n    'Back to reference ' +\n    (referenceIndex + 1) +\n    (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n  )\n}\n\n/**\n * Generate a hast footer for called footnote definitions.\n *\n * @param {State} state\n *   Info passed around.\n * @returns {Element | undefined}\n *   `section` element or `undefined`.\n */\n// eslint-disable-next-line complexity\nexport function footer(state) {\n  const clobberPrefix =\n    typeof state.options.clobberPrefix === 'string'\n      ? state.options.clobberPrefix\n      : 'user-content-'\n  const footnoteBackContent =\n    state.options.footnoteBackContent || defaultFootnoteBackContent\n  const footnoteBackLabel =\n    state.options.footnoteBackLabel || defaultFootnoteBackLabel\n  const footnoteLabel = state.options.footnoteLabel || 'Footnotes'\n  const footnoteLabelTagName = state.options.footnoteLabelTagName || 'h2'\n  const footnoteLabelProperties = state.options.footnoteLabelProperties || {\n    className: ['sr-only']\n  }\n  /** @type {Array<ElementContent>} */\n  const listItems = []\n  let referenceIndex = -1\n\n  while (++referenceIndex < state.footnoteOrder.length) {\n    const definition = state.footnoteById.get(\n      state.footnoteOrder[referenceIndex]\n    )\n\n    if (!definition) {\n      continue\n    }\n\n    const content = state.all(definition)\n    const id = String(definition.identifier).toUpperCase()\n    const safeId = normalizeUri(id.toLowerCase())\n    let rereferenceIndex = 0\n    /** @type {Array<ElementContent>} */\n    const backReferences = []\n    const counts = state.footnoteCounts.get(id)\n\n    // eslint-disable-next-line no-unmodified-loop-condition\n    while (counts !== undefined && ++rereferenceIndex <= counts) {\n      if (backReferences.length > 0) {\n        backReferences.push({type: 'text', value: ' '})\n      }\n\n      let children =\n        typeof footnoteBackContent === 'string'\n          ? footnoteBackContent\n          : footnoteBackContent(referenceIndex, rereferenceIndex)\n\n      if (typeof children === 'string') {\n        children = {type: 'text', value: children}\n      }\n\n      backReferences.push({\n        type: 'element',\n        tagName: 'a',\n        properties: {\n          href:\n            '#' +\n            clobberPrefix +\n            'fnref-' +\n            safeId +\n            (rereferenceIndex > 1 ? '-' + rereferenceIndex : ''),\n          dataFootnoteBackref: '',\n          ariaLabel:\n            typeof footnoteBackLabel === 'string'\n              ? footnoteBackLabel\n              : footnoteBackLabel(referenceIndex, rereferenceIndex),\n          className: ['data-footnote-backref']\n        },\n        children: Array.isArray(children) ? children : [children]\n      })\n    }\n\n    const tail = content[content.length - 1]\n\n    if (tail && tail.type === 'element' && tail.tagName === 'p') {\n      const tailTail = tail.children[tail.children.length - 1]\n      if (tailTail && tailTail.type === 'text') {\n        tailTail.value += ' '\n      } else {\n        tail.children.push({type: 'text', value: ' '})\n      }\n\n      tail.children.push(...backReferences)\n    } else {\n      content.push(...backReferences)\n    }\n\n    /** @type {Element} */\n    const listItem = {\n      type: 'element',\n      tagName: 'li',\n      properties: {id: clobberPrefix + 'fn-' + safeId},\n      children: state.wrap(content, true)\n    }\n\n    state.patch(definition, listItem)\n\n    listItems.push(listItem)\n  }\n\n  if (listItems.length === 0) {\n    return\n  }\n\n  return {\n    type: 'element',\n    tagName: 'section',\n    properties: {dataFootnotes: true, className: ['footnotes']},\n    children: [\n      {\n        type: 'element',\n        tagName: footnoteLabelTagName,\n        properties: {\n          ...structuredClone(footnoteLabelProperties),\n          id: 'footnote-label'\n        },\n        children: [{type: 'text', value: footnoteLabel}]\n      },\n      {type: 'text', value: '\\n'},\n      {\n        type: 'element',\n        tagName: 'ol',\n        properties: {},\n        children: state.wrap(listItems, true)\n      },\n      {type: 'text', value: '\\n'}\n    ]\n  }\n}\n","/**\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').ElementContent} HastElementContent\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {import('hast').RootContent} HastRootContent\n * @typedef {import('hast').Text} HastText\n *\n * @typedef {import('mdast').Definition} MdastDefinition\n * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('mdast').Parents} MdastParents\n *\n * @typedef {import('vfile').VFile} VFile\n *\n * @typedef {import('./footer.js').FootnoteBackContentTemplate} FootnoteBackContentTemplate\n * @typedef {import('./footer.js').FootnoteBackLabelTemplate} FootnoteBackLabelTemplate\n */\n\n/**\n * @callback Handler\n *   Handle a node.\n * @param {State} state\n *   Info passed around.\n * @param {any} node\n *   mdast node to handle.\n * @param {MdastParents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<HastElementContent> | HastElementContent | undefined}\n *   hast node.\n *\n * @typedef {Partial<Record<MdastNodes['type'], Handler>>} Handlers\n *   Handle nodes.\n *\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean | null | undefined} [allowDangerousHtml=false]\n *   Whether to persist raw HTML in markdown in the hast tree (default:\n *   `false`).\n * @property {string | null | undefined} [clobberPrefix='user-content-']\n *   Prefix to use before the `id` property on footnotes to prevent them from\n *   *clobbering* (default: `'user-content-'`).\n *\n *   Pass `''` for trusted markdown and when you are careful with\n *   polyfilling.\n *   You could pass a different prefix.\n *\n *   DOM clobbering is this:\n *\n *   ```html\n *   <p id=\"x\"></p>\n *   <script>alert(x) // `x` now refers to the `p#x` DOM element</script>\n *   ```\n *\n *   The above example shows that elements are made available by browsers, by\n *   their ID, on the `window` object.\n *   This is a security risk because you might be expecting some other variable\n *   at that place.\n *   It can also break polyfills.\n *   Using a prefix solves these problems.\n * @property {VFile | null | undefined} [file]\n *   Corresponding virtual file representing the input document (optional).\n * @property {FootnoteBackContentTemplate | string | null | undefined} [footnoteBackContent]\n *   Content of the backreference back to references (default: `defaultFootnoteBackContent`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackContent(_, rereferenceIndex) {\n *     const result = [{type: 'text', value: '↩'}]\n *\n *     if (rereferenceIndex > 1) {\n *       result.push({\n *         type: 'element',\n *         tagName: 'sup',\n *         properties: {},\n *         children: [{type: 'text', value: String(rereferenceIndex)}]\n *       })\n *     }\n *\n *     return result\n *   }\n *   ```\n *\n *   This content is used in the `a` element of each backreference (the `↩`\n *   links).\n * @property {FootnoteBackLabelTemplate | string | null | undefined} [footnoteBackLabel]\n *   Label to describe the backreference back to references (default:\n *   `defaultFootnoteBackLabel`).\n *\n *   The default value is:\n *\n *   ```js\n *   function defaultFootnoteBackLabel(referenceIndex, rereferenceIndex) {\n *    return (\n *      'Back to reference ' +\n *      (referenceIndex + 1) +\n *      (rereferenceIndex > 1 ? '-' + rereferenceIndex : '')\n *    )\n *   }\n *   ```\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is used in the `ariaLabel` property on each backreference\n *   (the `↩` links).\n *   It affects users of assistive technology.\n * @property {string | null | undefined} [footnoteLabel='Footnotes']\n *   Textual label to use for the footnotes section (default: `'Footnotes'`).\n *\n *   Change it when the markdown is not in English.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {HastProperties | null | undefined} [footnoteLabelProperties={className: ['sr-only']}]\n *   Properties to use on the footnote label (default: `{className:\n *   ['sr-only']}`).\n *\n *   Change it to show the label and add other properties.\n *\n *   This label is typically hidden visually (assuming an `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass an empty string.\n *   You can also add different properties.\n *\n *   > **Note**: `id: 'footnote-label'` is always added, because footnote\n *   > calls use it with `aria-describedby` to provide an accessible label.\n * @property {string | null | undefined} [footnoteLabelTagName='h2']\n *   HTML tag name to use for the footnote label element (default: `'h2'`).\n *\n *   Change it to match your document structure.\n *\n *   This label is typically hidden visually (assuming a `sr-only` CSS class\n *   is defined that does that) and so affects screen readers only.\n *   If you do have such a class, but want to show this section to everyone,\n *   pass different properties with the `footnoteLabelProperties` option.\n * @property {Handlers | null | undefined} [handlers]\n *   Extra handlers for nodes (optional).\n * @property {Array<MdastNodes['type']> | null | undefined} [passThrough]\n *   List of custom mdast node types to pass through (keep) in hast (note that\n *   the node itself is passed, but eventual children are transformed)\n *   (optional).\n * @property {Handler | null | undefined} [unknownHandler]\n *   Handler for all unknown nodes (optional).\n *\n * @typedef State\n *   Info passed around.\n * @property {(node: MdastNodes) => Array<HastElementContent>} all\n *   Transform the children of an mdast parent to hast.\n * @property {<Type extends HastNodes>(from: MdastNodes, to: Type) => HastElement | Type} applyData\n *   Honor the `data` of `from`, and generate an element instead of `node`.\n * @property {Map<string, MdastDefinition>} definitionById\n *   Definitions by their identifier.\n * @property {Map<string, MdastFootnoteDefinition>} footnoteById\n *   Footnote definitions by their identifier.\n * @property {Map<string, number>} footnoteCounts\n *   Counts for how often the same footnote was called.\n * @property {Array<string>} footnoteOrder\n *   Identifiers of order when footnote calls first appear in tree order.\n * @property {Handlers} handlers\n *   Applied handlers.\n * @property {(node: MdastNodes, parent: MdastParents | undefined) => Array<HastElementContent> | HastElementContent | undefined} one\n *   Transform an mdast node to hast.\n * @property {Options} options\n *   Configuration.\n * @property {(from: MdastNodes, node: HastNodes) => undefined} patch\n *   Copy a node’s positional info.\n * @property {<Type extends HastRootContent>(nodes: Array<Type>, loose?: boolean | undefined) => Array<HastText | Type>} wrap\n *   Wrap `nodes` with line endings between each node, adds initial/final line endings when `loose`.\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {visit} from 'unist-util-visit'\nimport {position} from 'unist-util-position'\nimport {handlers as defaultHandlers} from './handlers/index.js'\n\nconst own = {}.hasOwnProperty\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Create `state` from an mdast tree.\n *\n * @param {MdastNodes} tree\n *   mdast node to transform.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {State}\n *   `state` function.\n */\nexport function createState(tree, options) {\n  const settings = options || emptyOptions\n  /** @type {Map<string, MdastDefinition>} */\n  const definitionById = new Map()\n  /** @type {Map<string, MdastFootnoteDefinition>} */\n  const footnoteById = new Map()\n  /** @type {Map<string, number>} */\n  const footnoteCounts = new Map()\n  /** @type {Handlers} */\n  // @ts-expect-error: the root handler returns a root.\n  // Hard to type.\n  const handlers = {...defaultHandlers, ...settings.handlers}\n\n  /** @type {State} */\n  const state = {\n    all,\n    applyData,\n    definitionById,\n    footnoteById,\n    footnoteCounts,\n    footnoteOrder: [],\n    handlers,\n    one,\n    options: settings,\n    patch,\n    wrap\n  }\n\n  visit(tree, function (node) {\n    if (node.type === 'definition' || node.type === 'footnoteDefinition') {\n      const map = node.type === 'definition' ? definitionById : footnoteById\n      const id = String(node.identifier).toUpperCase()\n\n      // Mimick CM behavior of link definitions.\n      // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/9032189/lib/index.js#L20-L21>.\n      if (!map.has(id)) {\n        // @ts-expect-error: node type matches map.\n        map.set(id, node)\n      }\n    }\n  })\n\n  return state\n\n  /**\n   * Transform an mdast node into a hast node.\n   *\n   * @param {MdastNodes} node\n   *   mdast node.\n   * @param {MdastParents | undefined} [parent]\n   *   Parent of `node`.\n   * @returns {Array<HastElementContent> | HastElementContent | undefined}\n   *   Resulting hast node.\n   */\n  function one(node, parent) {\n    const type = node.type\n    const handle = state.handlers[type]\n\n    if (own.call(state.handlers, type) && handle) {\n      return handle(state, node, parent)\n    }\n\n    if (state.options.passThrough && state.options.passThrough.includes(type)) {\n      if ('children' in node) {\n        const {children, ...shallow} = node\n        const result = structuredClone(shallow)\n        // @ts-expect-error: TS doesn’t understand…\n        result.children = state.all(node)\n        // @ts-expect-error: TS doesn’t understand…\n        return result\n      }\n\n      // @ts-expect-error: it’s custom.\n      return structuredClone(node)\n    }\n\n    const unknown = state.options.unknownHandler || defaultUnknownHandler\n\n    return unknown(state, node, parent)\n  }\n\n  /**\n   * Transform the children of an mdast node into hast nodes.\n   *\n   * @param {MdastNodes} parent\n   *   mdast node to compile\n   * @returns {Array<HastElementContent>}\n   *   Resulting hast nodes.\n   */\n  function all(parent) {\n    /** @type {Array<HastElementContent>} */\n    const values = []\n\n    if ('children' in parent) {\n      const nodes = parent.children\n      let index = -1\n      while (++index < nodes.length) {\n        const result = state.one(nodes[index], parent)\n\n        // To do: see if we van clean this? Can we merge texts?\n        if (result) {\n          if (index && nodes[index - 1].type === 'break') {\n            if (!Array.isArray(result) && result.type === 'text') {\n              result.value = trimMarkdownSpaceStart(result.value)\n            }\n\n            if (!Array.isArray(result) && result.type === 'element') {\n              const head = result.children[0]\n\n              if (head && head.type === 'text') {\n                head.value = trimMarkdownSpaceStart(head.value)\n              }\n            }\n          }\n\n          if (Array.isArray(result)) {\n            values.push(...result)\n          } else {\n            values.push(result)\n          }\n        }\n      }\n    }\n\n    return values\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {MdastNodes} from\n *   mdast node to copy from.\n * @param {HastNodes} to\n *   hast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(from, to) {\n  if (from.position) to.position = position(from)\n}\n\n/**\n * Honor the `data` of `from` and maybe generate an element instead of `to`.\n *\n * @template {HastNodes} Type\n *   Node type.\n * @param {MdastNodes} from\n *   mdast node to use data from.\n * @param {Type} to\n *   hast node to change.\n * @returns {HastElement | Type}\n *   Nothing.\n */\nfunction applyData(from, to) {\n  /** @type {HastElement | Type} */\n  let result = to\n\n  // Handle `data.hName`, `data.hProperties, `data.hChildren`.\n  if (from && from.data) {\n    const hName = from.data.hName\n    const hChildren = from.data.hChildren\n    const hProperties = from.data.hProperties\n\n    if (typeof hName === 'string') {\n      // Transforming the node resulted in an element with a different name\n      // than wanted:\n      if (result.type === 'element') {\n        result.tagName = hName\n      }\n      // Transforming the node resulted in a non-element, which happens for\n      // raw, text, and root nodes (unless custom handlers are passed).\n      // The intent of `hName` is to create an element, but likely also to keep\n      // the content around (otherwise: pass `hChildren`).\n      else {\n        /** @type {Array<HastElementContent>} */\n        // @ts-expect-error: assume no doctypes in `root`.\n        const children = 'children' in result ? result.children : [result]\n        result = {type: 'element', tagName: hName, properties: {}, children}\n      }\n    }\n\n    if (result.type === 'element' && hProperties) {\n      Object.assign(result.properties, structuredClone(hProperties))\n    }\n\n    if (\n      'children' in result &&\n      result.children &&\n      hChildren !== null &&\n      hChildren !== undefined\n    ) {\n      result.children = hChildren\n    }\n  }\n\n  return result\n}\n\n/**\n * Transform an unknown node.\n *\n * @param {State} state\n *   Info passed around.\n * @param {MdastNodes} node\n *   Unknown mdast node.\n * @returns {HastElement | HastText}\n *   Resulting hast node.\n */\nfunction defaultUnknownHandler(state, node) {\n  const data = node.data || {}\n  /** @type {HastElement | HastText} */\n  const result =\n    'value' in node &&\n    !(own.call(data, 'hProperties') || own.call(data, 'hChildren'))\n      ? {type: 'text', value: node.value}\n      : {\n          type: 'element',\n          tagName: 'div',\n          properties: {},\n          children: state.all(node)\n        }\n\n  state.patch(node, result)\n  return state.applyData(node, result)\n}\n\n/**\n * Wrap `nodes` with line endings between each node.\n *\n * @template {HastRootContent} Type\n *   Node type.\n * @param {Array<Type>} nodes\n *   List of nodes to wrap.\n * @param {boolean | undefined} [loose=false]\n *   Whether to add line endings at start and end (default: `false`).\n * @returns {Array<HastText | Type>}\n *   Wrapped nodes.\n */\nexport function wrap(nodes, loose) {\n  /** @type {Array<HastText | Type>} */\n  const result = []\n  let index = -1\n\n  if (loose) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  while (++index < nodes.length) {\n    if (index) result.push({type: 'text', value: '\\n'})\n    result.push(nodes[index])\n  }\n\n  if (loose && nodes.length > 0) {\n    result.push({type: 'text', value: '\\n'})\n  }\n\n  return result\n}\n\n/**\n * Trim spaces and tabs at the start of `value`.\n *\n * @param {string} value\n *   Value to trim.\n * @returns {string}\n *   Result.\n */\nfunction trimMarkdownSpaceStart(value) {\n  let index = 0\n  let code = value.charCodeAt(index)\n\n  while (code === 9 || code === 32) {\n    index++\n    code = value.charCodeAt(index)\n  }\n\n  return value.slice(index)\n}\n","/**\n * @typedef {import('hast').Nodes} HastNodes\n * @typedef {import('mdast').Nodes} MdastNodes\n * @typedef {import('./state.js').Options} Options\n */\n\nimport {ok as assert} from 'devlop'\nimport {footer} from './footer.js'\nimport {createState} from './state.js'\n\n/**\n * Transform mdast to hast.\n *\n * ##### Notes\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most utilities ignore `raw` nodes but two notable ones don’t:\n *\n * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will\n *     output the raw HTML.\n *     This is typically discouraged as noted by the option name but is useful\n *     if you completely trust authors\n * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them\n *     into standard hast nodes (`element`, `text`, etc).\n *     This is a heavy task as it needs a full HTML parser, but it is the only\n *     way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark, which we follow by default.\n * They are supported by GitHub, so footnotes can be enabled in markdown with\n * `mdast-util-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes, which is hidden for sighted users but shown to\n * assistive technology.\n * When your page is not in English, you must define translated values.\n *\n * Back references use ARIA attributes, but the section label itself uses a\n * heading that is hidden with an `sr-only` class.\n * To show it to sighted users, define different attributes in\n * `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem, as it links footnote calls to footnote\n * definitions on the page through `id` attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * Example: headings (DOM clobbering) in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * *   when the node has a `value` (and doesn’t have `data.hName`,\n *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`\n *     node\n * *   otherwise, create a `<div>` element (which could be changed with\n *     `data.hName`), with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @param {MdastNodes} tree\n *   mdast tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {HastNodes}\n *   hast tree.\n */\nexport function toHast(tree, options) {\n  const state = createState(tree, options)\n  const node = state.one(tree, undefined)\n  const foot = footer(state)\n  /** @type {HastNodes} */\n  const result = Array.isArray(node)\n    ? {type: 'root', children: node}\n    : node || {type: 'root', children: []}\n\n  if (foot) {\n    // If there’s a footer, there were definitions, meaning block\n    // content.\n    // So `result` is a parent node.\n    assert('children' in result)\n    result.children.push({type: 'text', value: '\\n'}, foot)\n  }\n\n  return result\n}\n","/**\n * @import {Root as HastRoot} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n * @import {Options as ToHastOptions} from 'mdast-util-to-hast'\n * @import {Processor} from 'unified'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @typedef {Omit<ToHastOptions, 'file'>} Options\n *\n * @callback TransformBridge\n *   Bridge-mode.\n *\n *   Runs the destination with the new hast tree.\n *   Discards result.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {Promise<undefined>}\n *   Nothing.\n *\n * @callback TransformMutate\n *  Mutate-mode.\n *\n *  Further transformers run on the hast tree.\n * @param {MdastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {HastRoot}\n *   Tree (hast).\n */\n\nimport {toHast} from 'mdast-util-to-hast'\n\n/**\n * Turn markdown into HTML.\n *\n * ##### Notes\n *\n * ###### Signature\n *\n * * if a processor is given,\n *   runs the (rehype) plugins used on it with a hast tree,\n *   then discards the result (*bridge mode*)\n * * otherwise,\n *   returns a hast tree,\n *   the plugins used after `remarkRehype` are rehype plugins (*mutate mode*)\n *\n * > 👉 **Note**:\n * > It’s highly unlikely that you want to pass a `processor`.\n *\n * ###### HTML\n *\n * Raw HTML is available in mdast as `html` nodes and can be embedded in hast\n * as semistandard `raw` nodes.\n * Most plugins ignore `raw` nodes but two notable ones don’t:\n *\n * * `rehype-stringify` also has an option `allowDangerousHtml` which will\n *   output the raw HTML.\n *   This is typically discouraged as noted by the option name but is useful if\n *   you completely trust authors\n * * `rehype-raw` can handle the raw embedded HTML strings by parsing them\n *   into standard hast nodes (`element`, `text`, etc);\n *   this is a heavy task as it needs a full HTML parser,\n *   but it is the only way to support untrusted content\n *\n * ###### Footnotes\n *\n * Many options supported here relate to footnotes.\n * Footnotes are not specified by CommonMark,\n * which we follow by default.\n * They are supported by GitHub,\n * so footnotes can be enabled in markdown with `remark-gfm`.\n *\n * The options `footnoteBackLabel` and `footnoteLabel` define natural language\n * that explains footnotes,\n * which is hidden for sighted users but shown to assistive technology.\n * When your page is not in English,\n * you must define translated values.\n *\n * Back references use ARIA attributes,\n * but the section label itself uses a heading that is hidden with an\n * `sr-only` class.\n * To show it to sighted users,\n * define different attributes in `footnoteLabelProperties`.\n *\n * ###### Clobbering\n *\n * Footnotes introduces a problem,\n * as it links footnote calls to footnote definitions on the page through `id`\n * attributes generated from user content,\n * which results in DOM clobbering.\n *\n * DOM clobbering is this:\n *\n * ```html\n * <p id=x></p>\n * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>\n * ```\n *\n * Elements by their ID are made available by browsers on the `window` object,\n * which is a security risk.\n * Using a prefix solves this problem.\n *\n * More information on how to handle clobbering and the prefix is explained in\n * *Example: headings (DOM clobbering)* in `rehype-sanitize`.\n *\n * ###### Unknown nodes\n *\n * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.\n * The default behavior for unknown nodes is:\n *\n * * when the node has a `value`\n *   (and doesn’t have `data.hName`, `data.hProperties`, or `data.hChildren`,\n *   see later),\n *   create a hast `text` node\n * * otherwise,\n *   create a `<div>` element (which could be changed with `data.hName`),\n *   with its children mapped from mdast to hast as well\n *\n * This behavior can be changed by passing an `unknownHandler`.\n *\n * @overload\n * @param {Processor} processor\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformBridge}\n *\n * @overload\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformMutate}\n *\n * @overload\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\n * @param {Readonly<Options> | null | undefined} [options]\n * @returns {TransformBridge | TransformMutate}\n *\n * @param {Readonly<Options> | Processor | null | undefined} [destination]\n *   Processor or configuration (optional).\n * @param {Readonly<Options> | null | undefined} [options]\n *   When a processor was given,\n *   configuration (optional).\n * @returns {TransformBridge | TransformMutate}\n *   Transform.\n */\nexport default function remarkRehype(destination, options) {\n  if (destination && 'run' in destination) {\n    /**\n     * @type {TransformBridge}\n     */\n    return async function (tree, file) {\n      // Cast because root in -> root out.\n      const hastTree = /** @type {HastRoot} */ (\n        toHast(tree, {file, ...options})\n      )\n      await destination.run(hastTree, file)\n    }\n  }\n\n  /**\n   * @type {TransformMutate}\n   */\n  return function (tree, file) {\n    // Cast because root in -> root out.\n    // To do: in the future, disallow ` || options` fallback.\n    // With `unified-engine`, `destination` can be `undefined` but\n    // `options` will be the file set.\n    // We should not pass that as `options`.\n    return /** @type {HastRoot} */ (\n      toHast(tree, {file, ...(destination || options)})\n    )\n  }\n}\n"],"names":["normalizeUri","value","result","index","start","skip","code","replace","asciiAlphanumeric","next","blockquote","state","node","hardBreak","properties","strikethrough","emphasis","footnoteReference","clobberPrefix","id","safeId","counter","reuseCounter","link","sup","heading","html","revert","subtype","suffix","contents","head","tail","imageReference","definition","image","inlineCode","text","linkReference","listItem","parent","results","loose","listLoose","listItemLoose","children","paragraph","child","spread","list","root","strong","table","rows","firstRow","tableContent","body","pointStart","end","pointEnd","tableRow","siblings","tagName","align","length","cellIndex","cells","cell","alignValue","tableCell","tab","space","trimLines","source","search","match","last","lines","trimLine","startIndex","endIndex","thematicBreak","handlers","ignore","defaultFootnoteBackContent","_","rereferenceIndex","defaultFootnoteBackLabel","referenceIndex","footer","footnoteBackContent","footnoteBackLabel","footnoteLabel","footnoteLabelTagName","footnoteLabelProperties","listItems","content","backReferences","counts","tailTail","structuredClone","own","emptyOptions","createState","tree","options","settings","definitionById","footnoteById","footnoteCounts","defaultHandlers","all","applyData","one","patch","wrap","visit","map","type","handle","shallow","defaultUnknownHandler","values","nodes","trimMarkdownSpaceStart","from","to","position","hName","hChildren","hProperties","data","toHast","foot","remarkRehype","destination","file","hastTree"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30]}