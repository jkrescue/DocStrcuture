{"version":3,"file":"index-74e7b99c.js","sources":["../../node_modules/mdast-util-to-markdown/lib/configure.js","../../node_modules/mdast-util-to-markdown/lib/join.js","../../node_modules/mdast-util-to-markdown/lib/unsafe.js","../../node_modules/mdast-util-to-markdown/lib/util/association.js","../../node_modules/mdast-util-to-markdown/lib/util/compile-pattern.js","../../node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js","../../node_modules/mdast-util-to-markdown/lib/util/container-flow.js","../../node_modules/mdast-util-to-markdown/lib/util/indent-lines.js","../../node_modules/mdast-util-to-markdown/lib/util/safe.js","../../node_modules/mdast-util-to-markdown/lib/util/track.js","../../node_modules/mdast-util-to-markdown/lib/index.js","../../node_modules/remark-stringify/lib/index.js"],"sourcesContent":["/**\n * @import {Options, State} from './types.js'\n */\n\nconst own = {}.hasOwnProperty\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (own.call(extension, key)) {\n      switch (key) {\n        case 'extensions': {\n          // Empty.\n          break\n        }\n\n        /* c8 ignore next 4 */\n        case 'unsafe': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'join': {\n          list(base[key], extension[key])\n          break\n        }\n\n        case 'handlers': {\n          map(base[key], extension[key])\n          break\n        }\n\n        default: {\n          // @ts-expect-error: matches.\n          base.options[key] = extension[key]\n        }\n      }\n    }\n  }\n\n  return base\n}\n\n/**\n * @template T\n * @param {Array<T>} left\n * @param {Array<T> | null | undefined} right\n */\nfunction list(left, right) {\n  if (right) {\n    left.push(...right)\n  }\n}\n\n/**\n * @template T\n * @param {Record<string, T>} left\n * @param {Record<string, T> | null | undefined} right\n */\nfunction map(left, right) {\n  if (right) {\n    Object.assign(left, right)\n  }\n}\n","/**\n * @import {Join} from 'mdast-util-to-markdown'\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n","/**\n * @import {ConstructName, Unsafe} from 'mdast-util-to-markdown'\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n","/**\n * @import {AssociationId} from '../types.js'\n */\n\nimport {decodeString} from 'micromark-util-decode-string'\n\n/**\n * Get an identifier from an association to match it to others.\n *\n * Associations are nodes that match to something else through an ID:\n * <https://github.com/syntax-tree/mdast#association>.\n *\n * The `label` of an association is the string value: character escapes and\n * references work, and casing is intact.\n * The `identifier` is used to match one association to another:\n * controversially, character escapes and references don’t work in this\n * matching: `&copy;` does not match `©`, and `\\+` does not match `+`.\n *\n * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\\nb`\n * matches `a b`.\n * So, we do prefer the label when figuring out how we’re going to serialize:\n * it has whitespace, casing, and we can ignore most useless character\n * escapes and all character references.\n *\n * @type {AssociationId}\n */\nexport function association(node) {\n  if (node.label || !node.identifier) {\n    return node.label || ''\n  }\n\n  return decodeString(node.identifier)\n}\n","/**\n * @import {CompilePattern} from '../types.js'\n */\n\n/**\n * @type {CompilePattern}\n */\nexport function compilePattern(pattern) {\n  if (!pattern._compiled) {\n    const before =\n      (pattern.atBreak ? '[\\\\r\\\\n][\\\\t ]*' : '') +\n      (pattern.before ? '(?:' + pattern.before + ')' : '')\n\n    pattern._compiled = new RegExp(\n      (before ? '(' + before + ')' : '') +\n        (/[|\\\\{}()[\\]^$+*?.-]/.test(pattern.character) ? '\\\\' : '') +\n        pattern.character +\n        (pattern.after ? '(?:' + pattern.after + ')' : ''),\n      'g'\n    )\n  }\n\n  return pattern._compiled\n}\n","/**\n * @import {Handle, Info, State} from 'mdast-util-to-markdown'\n * @import {PhrasingParents} from '../types.js'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nexport function containerPhrasing(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n  let before = info.before\n  /** @type {string | undefined} */\n  let encodeAfter\n\n  indexStack.push(-1)\n  let tracker = state.createTracker(info)\n\n  while (++index < children.length) {\n    const child = children[index]\n    /** @type {string} */\n    let after\n\n    indexStack[indexStack.length - 1] = index\n\n    if (index + 1 < children.length) {\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      let handle = state.handle.handlers[children[index + 1].type]\n      /** @type {Handle} */\n      // @ts-expect-error: hush, it’s actually a `zwitch`.\n      if (handle && handle.peek) handle = handle.peek\n      after = handle\n        ? handle(children[index + 1], parent, state, {\n            before: '',\n            after: '',\n            ...tracker.current()\n          }).charAt(0)\n        : ''\n    } else {\n      after = info.after\n    }\n\n    // In some cases, html (text) can be found in phrasing right after an eol.\n    // When we’d serialize that, in most cases that would be seen as html\n    // (flow).\n    // As we can’t escape or so to prevent it from happening, we take a somewhat\n    // reasonable approach: replace that eol with a space.\n    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>\n    if (\n      results.length > 0 &&\n      (before === '\\r' || before === '\\n') &&\n      child.type === 'html'\n    ) {\n      results[results.length - 1] = results[results.length - 1].replace(\n        /(\\r?\\n|\\r)$/,\n        ' '\n      )\n      before = ' '\n\n      // To do: does this work to reset tracker?\n      tracker = state.createTracker(info)\n      tracker.move(results.join(''))\n    }\n\n    let value = state.handle(child, parent, state, {\n      ...tracker.current(),\n      after,\n      before\n    })\n\n    // If we had to encode the first character after the previous node and it’s\n    // still the same character,\n    // encode it.\n    if (encodeAfter && encodeAfter === value.slice(0, 1)) {\n      value =\n        encodeCharacterReference(encodeAfter.charCodeAt(0)) + value.slice(1)\n    }\n\n    const encodingInfo = state.attentionEncodeSurroundingInfo\n    state.attentionEncodeSurroundingInfo = undefined\n    encodeAfter = undefined\n\n    // If we have to encode the first character before the current node and\n    // it’s still the same character,\n    // encode it.\n    if (encodingInfo) {\n      if (\n        results.length > 0 &&\n        encodingInfo.before &&\n        before === results[results.length - 1].slice(-1)\n      ) {\n        results[results.length - 1] =\n          results[results.length - 1].slice(0, -1) +\n          encodeCharacterReference(before.charCodeAt(0))\n      }\n\n      if (encodingInfo.after) encodeAfter = after\n    }\n\n    tracker.move(value)\n    results.push(value)\n    before = value.slice(-1)\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n","/**\n * @import {State} from 'mdast-util-to-markdown'\n * @import {FlowChildren, FlowParents, TrackFields} from '../types.js'\n */\n\n/**\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nexport function containerFlow(parent, state, info) {\n  const indexStack = state.indexStack\n  const children = parent.children || []\n  const tracker = state.createTracker(info)\n  /** @type {Array<string>} */\n  const results = []\n  let index = -1\n\n  indexStack.push(-1)\n\n  while (++index < children.length) {\n    const child = children[index]\n\n    indexStack[indexStack.length - 1] = index\n\n    results.push(\n      tracker.move(\n        state.handle(child, parent, state, {\n          before: '\\n',\n          after: '\\n',\n          ...tracker.current()\n        })\n      )\n    )\n\n    if (child.type !== 'list') {\n      state.bulletLastUsed = undefined\n    }\n\n    if (index < children.length - 1) {\n      results.push(\n        tracker.move(between(child, children[index + 1], parent, state))\n      )\n    }\n  }\n\n  indexStack.pop()\n\n  return results.join('')\n}\n\n/**\n * @param {FlowChildren} left\n * @param {FlowChildren} right\n * @param {FlowParents} parent\n * @param {State} state\n * @returns {string}\n */\nfunction between(left, right, parent, state) {\n  let index = state.join.length\n\n  while (index--) {\n    const result = state.join[index](left, right, parent, state)\n\n    if (result === true || result === 1) {\n      break\n    }\n\n    if (typeof result === 'number') {\n      return '\\n'.repeat(1 + result)\n    }\n\n    if (result === false) {\n      return '\\n\\n<!---->\\n\\n'\n    }\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @import {IndentLines} from '../types.js'\n */\n\nconst eol = /\\r?\\n|\\r/g\n\n/**\n * @type {IndentLines}\n */\nexport function indentLines(value, map) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  let line = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = eol.exec(value))) {\n    one(value.slice(start, match.index))\n    result.push(match[0])\n    start = match.index + match[0].length\n    line++\n  }\n\n  one(value.slice(start))\n\n  return result.join('')\n\n  /**\n   * @param {string} value\n   */\n  function one(value) {\n    result.push(map(value, line, !value))\n  }\n}\n","/**\n * @import {SafeConfig, State} from 'mdast-util-to-markdown'\n */\n\nimport {encodeCharacterReference} from './encode-character-reference.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @param {State} state\n *   Info passed around about the current state.\n * @param {string | null | undefined} input\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nexport function safe(state, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index]\n\n    if (!patternInScope(state.stack, pattern)) {\n      continue\n    }\n\n    const expression = state.compilePattern(pattern)\n    /** @type {RegExpExecArray | null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(encodeCharacterReference(value.charCodeAt(position)))\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray | null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n","/**\n * @import {CreateTracker, TrackCurrent, TrackMove, TrackShift} from '../types.js'\n */\n\n/**\n * Track positional info in the output.\n *\n * @type {CreateTracker}\n */\nexport function track(config) {\n  // Defaults are used to prevent crashes when older utilities somehow activate\n  // this code.\n  /* c8 ignore next 5 */\n  const options = config || {}\n  const now = options.now || {}\n  let lineShift = options.lineShift || 0\n  let line = now.line || 1\n  let column = now.column || 1\n\n  return {move, current, shift}\n\n  /**\n   * Get the current tracked info.\n   *\n   * @type {TrackCurrent}\n   */\n  function current() {\n    return {now: {line, column}, lineShift}\n  }\n\n  /**\n   * Define an increased line shift (the typical indent for lines).\n   *\n   * @type {TrackShift}\n   */\n  function shift(value) {\n    lineShift += value\n  }\n\n  /**\n   * Move past some generated markdown.\n   *\n   * @type {TrackMove}\n   */\n  function move(input) {\n    // eslint-disable-next-line unicorn/prefer-default-parameters\n    const value = input || ''\n    const chunks = value.split(/\\r?\\n|\\r/g)\n    const tail = chunks[chunks.length - 1]\n    line += chunks.length - 1\n    column =\n      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift\n    return value\n  }\n}\n","/**\n * @import {Info, Join, Options, SafeConfig, State} from 'mdast-util-to-markdown'\n * @import {Nodes} from 'mdast'\n * @import {Enter, FlowParents, PhrasingParents, TrackFields} from './types.js'\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {compilePattern} from './util/compile-pattern.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Nodes} tree\n *   Tree to serialize.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options) {\n  const settings = options || {}\n  /** @type {State} */\n  const state = {\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    compilePattern,\n    enter,\n    // @ts-expect-error: GFM / frontmatter are typed in `mdast` but not defined\n    // here.\n    handlers: {...handlers},\n    // @ts-expect-error: add `handle` in a second.\n    handle: undefined,\n    indentLines,\n    indexStack: [],\n    join: [...join],\n    options: {},\n    safe: safeBound,\n    stack: [],\n    unsafe: [...unsafe]\n  }\n\n  configure(state, settings)\n\n  if (state.options.tightDefinitions) {\n    state.join.push(joinDefinition)\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    /**\n     * @returns {undefined}\n     */\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction unknown(value) {\n  // Always a node.\n  const node = /** @type {Nodes} */ (value)\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {PhrasingParents} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {FlowParents} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n","/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownOptions\n * @typedef {import('unified').Compiler<Root, string>} Compiler\n * @typedef {import('unified').Processor<undefined, undefined, undefined, Root, string>} Processor\n */\n\n/**\n * @typedef {Omit<ToMarkdownOptions, 'extensions'>} Options\n */\n\nimport {toMarkdown} from 'mdast-util-to-markdown'\n\n/**\n * Add support for serializing to markdown.\n *\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport default function remarkStringify(options) {\n  /** @type {Processor} */\n  // @ts-expect-error: TS in JSDoc generates wrong types if `this` is typed regularly.\n  const self = this\n\n  self.compiler = compiler\n\n  /**\n   * @type {Compiler}\n   */\n  function compiler(tree) {\n    return toMarkdown(tree, {\n      ...self.data('settings'),\n      ...options,\n      // Note: this option is not in the readme.\n      // The goal is for it to be set by plugins on `data` instead of being\n      // passed by users.\n      extensions: self.data('toMarkdownExtensions') || []\n    })\n  }\n}\n"],"names":["own","configure","base","extension","index","key","list","map","left","right","join","joinDefaults","parent","state","formatCodeAsIndented","formatHeadingAsSetext","fullPhrasingSpans","unsafe","association","node","decodeString","compilePattern","pattern","before","containerPhrasing","info","indexStack","children","results","encodeAfter","tracker","child","after","handle","value","encodeCharacterReference","encodingInfo","containerFlow","between","result","eol","indentLines","start","line","match","one","safe","input","config","positions","infos","patternInScope","expression","position","numerical","end","escapeBackslashes","a","b","whole","track","options","now","lineShift","column","move","current","shift","chunks","tail","toMarkdown","tree","settings","containerPhrasingBound","containerFlowBound","enter","handlers","safeBound","joinDefinition","zwitch","invalid","unknown","name","exit","remarkStringify","self","compiler"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}