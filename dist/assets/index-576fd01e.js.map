{"version":3,"file":"index-576fd01e.js","sources":["../../node_modules/rehype-minify-whitespace/lib/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/a.js","../../node_modules/hast-util-to-mdast/lib/handlers/base.js","../../node_modules/hast-util-to-mdast/lib/handlers/blockquote.js","../../node_modules/hast-util-to-mdast/lib/handlers/br.js","../../node_modules/unist-util-find-after/lib/index.js","../../node_modules/hast-util-to-text/lib/index.js","../../node_modules/trim-trailing-lines/index.js","../../node_modules/hast-util-to-mdast/lib/handlers/code.js","../../node_modules/hast-util-to-mdast/lib/handlers/comment.js","../../node_modules/hast-util-to-mdast/lib/handlers/del.js","../../node_modules/hast-util-to-mdast/lib/util/list-items-spread.js","../../node_modules/hast-util-to-mdast/lib/handlers/dl.js","../../node_modules/hast-util-to-mdast/lib/handlers/em.js","../../node_modules/hast-util-to-mdast/lib/util/drop-surrounding-breaks.js","../../node_modules/hast-util-to-mdast/lib/handlers/heading.js","../../node_modules/hast-util-to-mdast/lib/handlers/hr.js","../../node_modules/hast-util-to-mdast/lib/handlers/iframe.js","../../node_modules/hast-util-to-mdast/lib/handlers/img.js","../../node_modules/hast-util-to-mdast/lib/handlers/inline-code.js","../../node_modules/hast-util-to-mdast/lib/util/find-selected-options.js","../../node_modules/hast-util-to-mdast/lib/handlers/input.js","../../node_modules/hast-util-to-mdast/lib/handlers/li.js","../../node_modules/hast-util-to-mdast/lib/handlers/list.js","../../node_modules/hast-util-to-mdast/lib/util/wrap.js","../../node_modules/hast-util-to-mdast/lib/handlers/media.js","../../node_modules/hast-util-to-mdast/lib/handlers/p.js","../../node_modules/hast-util-to-mdast/lib/handlers/q.js","../../node_modules/hast-util-to-mdast/lib/handlers/root.js","../../node_modules/hast-util-to-mdast/lib/handlers/select.js","../../node_modules/hast-util-to-mdast/lib/handlers/strong.js","../../node_modules/hast-util-to-mdast/lib/handlers/table-cell.js","../../node_modules/hast-util-to-mdast/lib/handlers/table-row.js","../../node_modules/hast-util-to-mdast/lib/handlers/table.js","../../node_modules/hast-util-to-mdast/lib/handlers/text.js","../../node_modules/hast-util-to-mdast/lib/handlers/textarea.js","../../node_modules/hast-util-to-mdast/lib/handlers/wbr.js","../../node_modules/hast-util-to-mdast/lib/handlers/index.js","../../node_modules/hast-util-to-mdast/lib/state.js","../../node_modules/hast-util-to-mdast/lib/index.js","../../node_modules/rehype-remark/lib/index.js"],"sourcesContent":["/**\n * @import {Options} from 'hast-util-minify-whitespace'\n * @import {Root} from 'hast'\n */\n\nimport {minifyWhitespace} from 'hast-util-minify-whitespace'\n\n/**\n * Minify whitespace.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeMinifyWhitespace(options) {\n  /**\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    minifyWhitespace(tree, options)\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link}\n *   mdast node.\n */\nexport function a(state, node) {\n  const properties = node.properties || {}\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    url: state.resolve(String(properties.href || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {undefined}\n *   Nothing.\n */\nexport function base(state, node) {\n  if (!state.baseFound) {\n    state.frozenBaseUrl =\n      String((node.properties && node.properties.href) || '') || undefined\n    state.baseFound = true\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Blockquote} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Blockquote}\n *   mdast node.\n */\nexport function blockquote(state, node) {\n  /** @type {Blockquote} */\n  const result = {type: 'blockquote', children: state.toFlow(state.all(node))}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Break} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Break}\n *   mdast node.\n */\nexport function br(state, node) {\n  /** @type {Break} */\n  const result = {type: 'break'}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @typedef {import('unist').Node} UnistNode\n * @typedef {import('unist').Parent} UnistParent\n */\n\n/**\n * @typedef {Exclude<import('unist-util-is').Test, undefined> | undefined} Test\n *   Test from `unist-util-is`.\n *\n *   Note: we have remove and add `undefined`, because otherwise when generating\n *   automatic `.d.ts` files, TS tries to flatten paths from a local perspective,\n *   which doesn’t work when publishing on npm.\n */\n\n/**\n * @typedef {(\n *   Fn extends (value: any) => value is infer Thing\n *   ? Thing\n *   : Fallback\n * )} Predicate\n *   Get the value of a type guard `Fn`.\n * @template Fn\n *   Value; typically function that is a type guard (such as `(x): x is Y`).\n * @template Fallback\n *   Value to yield if `Fn` is not a type guard.\n */\n\n/**\n * @typedef {(\n *   Check extends null | undefined // No test.\n *   ? Value\n *   : Value extends {type: Check} // String (type) test.\n *   ? Value\n *   : Value extends Check // Partial test.\n *   ? Value\n *   : Check extends Function // Function test.\n *   ? Predicate<Check, Value> extends Value\n *     ? Predicate<Check, Value>\n *     : never\n *   : never // Some other test?\n * )} MatchesOne\n *   Check whether a node matches a primitive check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test, but not arrays.\n */\n\n/**\n * @typedef {(\n *   Check extends Array<any>\n *   ? MatchesOne<Value, Check[keyof Check]>\n *   : MatchesOne<Value, Check>\n * )} Matches\n *   Check whether a node matches a check in the type system.\n * @template Value\n *   Value; typically unist `Node`.\n * @template Check\n *   Value; typically `unist-util-is`-compatible test.\n */\n\n/**\n * @typedef {(\n *   Kind extends {children: Array<infer Child>}\n *   ? Child\n *   : never\n * )} Child\n *   Collect nodes that can be parents of `Child`.\n * @template {UnistNode} Kind\n *   All node types.\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Find the first node in `parent` after another `node` or after an index,\n * that passes `test`.\n *\n * @param parent\n *   Parent node.\n * @param index\n *   Child node or index.\n * @param [test=undefined]\n *   Test for child to look for (optional).\n * @returns\n *   A child (matching `test`, if given) or `undefined`.\n */\nexport const findAfter =\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  (\n    /**\n     * @param {UnistParent} parent\n     * @param {UnistNode | number} index\n     * @param {Test} [test]\n     * @returns {UnistNode | undefined}\n     */\n    function (parent, index, test) {\n      const is = convert(test)\n\n      if (!parent || !parent.type || !parent.children) {\n        throw new Error('Expected parent node')\n      }\n\n      if (typeof index === 'number') {\n        if (index < 0 || index === Number.POSITIVE_INFINITY) {\n          throw new Error('Expected positive finite number as index')\n        }\n      } else {\n        index = parent.children.indexOf(index)\n\n        if (index < 0) {\n          throw new Error('Expected child node or index')\n        }\n      }\n\n      while (++index < parent.children.length) {\n        if (is(parent.children[index], index, parent)) {\n          return parent.children[index]\n        }\n      }\n\n      return undefined\n    }\n  )\n","/**\n * @typedef {import('hast').Comment} Comment\n * @typedef {import('hast').Element} Element\n * @typedef {import('hast').Nodes} Nodes\n * @typedef {import('hast').Parents} Parents\n * @typedef {import('hast').Text} Text\n * @typedef {import('hast-util-is-element').TestFunction} TestFunction\n */\n\n/**\n * @typedef {'normal' | 'nowrap' | 'pre' | 'pre-wrap'} Whitespace\n *   Valid and useful whitespace values (from CSS).\n *\n * @typedef {0 | 1 | 2} BreakNumber\n *   Specific break:\n *\n *   *   `0` — space\n *   *   `1` — line ending\n *   *   `2` — blank line\n *\n * @typedef {'\\n'} BreakForce\n *   Forced break.\n *\n * @typedef {boolean} BreakValue\n *   Whether there was a break.\n *\n * @typedef {BreakNumber | BreakValue | undefined} BreakBefore\n *   Any value for a break before.\n *\n * @typedef {BreakForce | BreakNumber | BreakValue | undefined} BreakAfter\n *   Any value for a break after.\n *\n * @typedef CollectionInfo\n *   Info on current collection.\n * @property {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @property {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @property {Whitespace} whitespace\n *   Current whitespace setting.\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace | null | undefined} [whitespace='normal']\n *   Initial CSS whitespace setting to use (default: `'normal'`).\n */\n\nimport {findAfter} from 'unist-util-find-after'\nimport {convertElement} from 'hast-util-is-element'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst cell = convertElement(isCell)\nconst p = convertElement('p')\nconst row = convertElement('tr')\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/multipage/rendering.html#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'li', // Lists (as `display: list-item`)\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Get the plain-text value of a node.\n *\n * ###### Algorithm\n *\n * *   if `tree` is a comment, returns its `value`\n * *   if `tree` is a text, applies normal whitespace collapsing to its\n *     `value`, as defined by the CSS Text spec\n * *   if `tree` is a root or element, applies an algorithm similar to the\n *     `innerText` getter as defined by HTML\n *\n * ###### Notes\n *\n * > 👉 **Note**: the algorithm acts as if `tree` is being rendered, and as if\n * > we’re a CSS-supporting user agent, with scripting enabled.\n *\n * *   if `tree` is an element that is not displayed (such as a `head`), we’ll\n *     still use the `innerText` algorithm instead of switching to `textContent`\n * *   if descendants of `tree` are elements that are not displayed, they are\n *     ignored\n * *   CSS is not considered, except for the default user agent style sheet\n * *   a line feed is collapsed instead of ignored in cases where Fullwidth, Wide,\n *     or Halfwidth East Asian Width characters are used, the same goes for a case\n *     with Chinese, Japanese, or Yi writing systems\n * *   replaced elements (such as `audio`) are treated like non-replaced elements\n *\n * @param {Nodes} tree\n *   Tree to turn into text.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized `tree`.\n */\nexport function toText(tree, options) {\n  const options_ = options || {}\n  const children = 'children' in tree ? tree.children : []\n  const block = blockOrCaption(tree)\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options_.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n\n  /** @type {Array<BreakNumber | string>} */\n  const results = []\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (tree.type === 'text' || tree.type === 'comment') {\n    results.push(\n      ...collectText(tree, {\n        whitespace,\n        breakBefore: true,\n        breakAfter: true\n      })\n    )\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  let index = -1\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results.push(\n      ...renderedTextCollection(\n        children[index],\n        // @ts-expect-error: `tree` is a parent if we’re here.\n        tree,\n        {\n          whitespace,\n          breakBefore: index ? undefined : block,\n          breakAfter:\n            index < children.length - 1 ? br(children[index + 1]) : block\n        }\n      )\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {number | undefined} */\n  let count\n\n  index = -1\n\n  while (++index < results.length) {\n    const value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count !== undefined && count > -1) {\n        result.push('\\n'.repeat(count) || ' ')\n      }\n\n      count = -1\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/multipage/dom.html#rendered-text-collection-steps>\n *\n * @param {Nodes} node\n * @param {Parents} parent\n * @param {CollectionInfo} info\n * @returns {Array<BreakNumber | string>}\n */\nfunction renderedTextCollection(node, parent, info) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, info)\n  }\n\n  if (node.type === 'text') {\n    return info.whitespace === 'normal'\n      ? collectText(node, info)\n      : collectPreText(node)\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {Element} node\n *   Element node.\n * @param {Parents} parent\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n */\nfunction collectElement(node, parent, info) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, info)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array<BreakNumber | string>} */\n  let items = []\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  /** @type {BreakNumber | undefined} */\n  let prefix\n  /** @type {BreakForce | BreakNumber | undefined} */\n  let suffix\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (\n    row(node) &&\n    // @ts-expect-error: something up with types of parents.\n    findAfter(parent, node, row)\n  ) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      renderedTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/multipage/rendering.html#tables-2>\n  if (\n    cell(node) &&\n    // @ts-expect-error: something up with types of parents.\n    findAfter(parent, node, cell)\n  ) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {Comment | Text} node\n *   Text node.\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectText(node, info) {\n  const value = String(node.value)\n  /** @type {Array<string>} */\n  const lines = []\n  /** @type {Array<BreakNumber | string>} */\n  const result = []\n  let start = 0\n\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start\n\n    const match = searchLineFeeds.exec(value)\n    const end = match && 'index' in match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // […] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        start === 0 ? info.breakBefore : true,\n        end === value.length ? info.breakAfter : true\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  let index = -1\n  /** @type {BreakNumber | undefined} */\n  let join\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x20_0b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x20_0b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = undefined\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (typeof join === 'number') result.push(join)\n      result.push(lines[index])\n      join = 0\n    } else if (index === 0 || index === lines.length - 1) {\n      // If this line is empty, and it’s the first or last, add a space.\n      // Note that this function is only called in normal whitespace, so we\n      // don’t worry about `pre`.\n      result.push(0)\n    }\n  }\n\n  return result\n}\n\n/**\n * Collect a text node as “pre” whitespace.\n *\n * @param {Text} node\n *   Text node.\n * @returns {Array<BreakNumber | string>}\n *   Result.\n */\nfunction collectPreText(node) {\n  return [String(node.value)]\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n *   Value to collapse.\n * @param {BreakBefore} breakBefore\n *   Whether there was a break before.\n * @param {BreakAfter} breakAfter\n *   Whether there was a break after.\n * @returns {string}\n *   Result.\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array<string>} */\n  const result = []\n  let start = 0\n  /** @type {number | undefined} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    const match = searchTabOrSpaces.exec(value)\n    end = match ? match.index : value.length\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * Figure out the whitespace of a node.\n *\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {Nodes} node\n *   Node (typically `Element`).\n * @param {CollectionInfo} info\n *   Info on current collection.\n * @returns {Whitespace}\n *   Applied whitespace.\n */\nfunction inferWhitespace(node, info) {\n  if (node.type === 'element') {\n    const properties = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp': {\n        return 'pre'\n      }\n\n      case 'nobr': {\n        return 'nowrap'\n      }\n\n      case 'pre': {\n        return properties.wrap ? 'pre-wrap' : 'pre'\n      }\n\n      case 'td':\n      case 'th': {\n        return properties.noWrap ? 'nowrap' : info.whitespace\n      }\n\n      case 'textarea': {\n        return 'pre-wrap'\n      }\n\n      default:\n    }\n  }\n\n  return info.whitespace\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {properties: {hidden: true}}}\n */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/**\n * @type {TestFunction}\n * @param {Element} node\n * @returns {node is {tagName: 'td' | 'th'}}\n */\nfunction isCell(node) {\n  return node.tagName === 'td' || node.tagName === 'th'\n}\n\n/**\n * @type {TestFunction}\n */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n","/**\n * Remove final line endings from `value`\n *\n * @param {unknown} value\n *   Value with trailing line endings, coerced to string.\n * @return {string}\n *   Value without trailing line endings.\n */\nexport function trimTrailingLines(value) {\n  const input = String(value)\n  let end = input.length\n\n  while (end > 0) {\n    const code = input.codePointAt(end - 1)\n    if (code !== undefined && (code === 10 || code === 13)) {\n      end--\n    } else {\n      break\n    }\n  }\n\n  return input.slice(0, end)\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Code} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {trimTrailingLines} from 'trim-trailing-lines'\n\nconst prefix = 'language-'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Code}\n *   mdast node.\n */\nexport function code(state, node) {\n  const children = node.children\n  let index = -1\n  /** @type {Array<number | string> | undefined} */\n  let classList\n  /** @type {string | undefined} */\n  let lang\n\n  if (node.tagName === 'pre') {\n    while (++index < children.length) {\n      const child = children[index]\n\n      if (\n        child.type === 'element' &&\n        child.tagName === 'code' &&\n        child.properties &&\n        child.properties.className &&\n        Array.isArray(child.properties.className)\n      ) {\n        classList = child.properties.className\n        break\n      }\n    }\n  }\n\n  if (classList) {\n    index = -1\n\n    while (++index < classList.length) {\n      if (String(classList[index]).slice(0, prefix.length) === prefix) {\n        lang = String(classList[index]).slice(prefix.length)\n        break\n      }\n    }\n  }\n\n  /** @type {Code} */\n  const result = {\n    type: 'code',\n    lang: lang || null,\n    meta: null,\n    value: trimTrailingLines(toText(node))\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Comment} from 'hast'\n * @import {Html} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Comment>} node\n *   hast element to transform.\n * @returns {Html}\n *   mdast node.\n */\nexport function comment(state, node) {\n  /** @type {Html} */\n  const result = {\n    type: 'html',\n    value: '<!--' + node.value + '-->'\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Delete, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Delete}\n *   mdast node.\n */\nexport function del(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n  /** @type {Delete} */\n  const result = {type: 'delete', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {ListContent} from 'mdast'\n */\n\n/**\n * Infer whether list items are spread.\n *\n * @param {Readonly<Array<Readonly<ListContent>>>} children\n *   List items.\n * @returns {boolean}\n *   Whether one or more list items are spread.\n */\nexport function listItemsSpread(children) {\n  let index = -1\n\n  if (children.length > 1) {\n    while (++index < children.length) {\n      if (children[index].spread) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {ElementContent, Element} from 'hast'\n * @import {BlockContent, DefinitionContent, ListContent, ListItem, List} from 'mdast'\n */\n\n/**\n * @typedef Group\n *   Title/definition group.\n * @property {Array<Element>} titles\n *   One or more titles.\n * @property {Array<ElementContent>} definitions\n *   One or more definitions.\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List | undefined}\n *   mdast node.\n */\nexport function dl(state, node) {\n  /** @type {Array<ElementContent>} */\n  const clean = []\n  /** @type {Array<Group>} */\n  const groups = []\n  let index = -1\n\n  // Unwrap `<div>`s\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element' && child.tagName === 'div') {\n      clean.push(...child.children)\n    } else {\n      clean.push(child)\n    }\n  }\n\n  /** @type {Group} */\n  let group = {definitions: [], titles: []}\n  index = -1\n\n  // Group titles and definitions.\n  while (++index < clean.length) {\n    const child = clean[index]\n\n    if (child.type === 'element' && child.tagName === 'dt') {\n      const previous = clean[index - 1]\n\n      if (\n        previous &&\n        previous.type === 'element' &&\n        previous.tagName === 'dd'\n      ) {\n        groups.push(group)\n        group = {definitions: [], titles: []}\n      }\n\n      group.titles.push(child)\n    } else {\n      group.definitions.push(child)\n    }\n  }\n\n  groups.push(group)\n\n  // Create items.\n  index = -1\n  /** @type {Array<ListContent>} */\n  const content = []\n\n  while (++index < groups.length) {\n    const result = [\n      ...handle(state, groups[index].titles),\n      ...handle(state, groups[index].definitions)\n    ]\n\n    if (result.length > 0) {\n      content.push({\n        type: 'listItem',\n        spread: result.length > 1,\n        checked: null,\n        children: result\n      })\n    }\n  }\n\n  // Create a list if there are items.\n  if (content.length > 0) {\n    /** @type {List} */\n    const result = {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(content),\n      children: content\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Array<ElementContent>} children\n *   hast element children to transform.\n * @returns {Array<BlockContent | DefinitionContent>}\n *   mdast nodes.\n */\nfunction handle(state, children) {\n  const nodes = state.all({type: 'root', children})\n  const listItems = state.toSpecificContent(nodes, create)\n\n  if (listItems.length === 0) {\n    return []\n  }\n\n  if (listItems.length === 1) {\n    return listItems[0].children\n  }\n\n  return [\n    {\n      type: 'list',\n      ordered: false,\n      start: null,\n      spread: listItemsSpread(listItems),\n      children: listItems\n    }\n  ]\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Emphasis, PhrasingContent} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Emphasis}\n *   mdast node.\n */\nexport function em(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Emphasis} */\n  const result = {type: 'emphasis', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {Nodes} from 'mdast'\n */\n\n/**\n * Drop trailing initial and final `br`s.\n *\n * @template {Nodes} Node\n *   Node type.\n * @param {Array<Node>} nodes\n *   List of nodes.\n * @returns {Array<Node>}\n *   List of nodes w/o `break`s.\n */\nexport function dropSurroundingBreaks(nodes) {\n  let start = 0\n  let end = nodes.length\n\n  while (start < end && nodes[start].type === 'break') start++\n  while (end > start && nodes[end - 1].type === 'break') end--\n\n  return start === 0 && end === nodes.length ? nodes : nodes.slice(start, end)\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Heading, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Heading}\n *   mdast node.\n */\nexport function heading(state, node) {\n  const depth = /** @type {Heading['depth']} */ (\n    /* c8 ignore next */\n    Number(node.tagName.charAt(1)) || 1\n  )\n  const children = dropSurroundingBreaks(\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  /** @type {Heading} */\n  const result = {type: 'heading', depth, children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ThematicBreak} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ThematicBreak}\n *   mdast node.\n */\nexport function hr(state, node) {\n  /** @type {ThematicBreak} */\n  const result = {type: 'thematicBreak'}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Link} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Link | undefined}\n *   mdast node.\n */\nexport function iframe(state, node) {\n  const properties = node.properties || {}\n  const source = String(properties.src || '')\n  const title = String(properties.title || '')\n\n  // Only create a link if there is a title.\n  // We can’t use the content of the frame because conforming HTML parsers treat\n  // it as text, whereas legacy parsers treat it as HTML, so it will likely\n  // contain tags that will show up in text.\n  if (source && title) {\n    /** @type {Link} */\n    const result = {\n      type: 'link',\n      title: null,\n      url: state.resolve(source),\n      children: [{type: 'text', value: title}]\n    }\n    state.patch(node, result)\n    return result\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Image}\n *   mdast node.\n */\nexport function img(state, node) {\n  const properties = node.properties || {}\n\n  /** @type {Image} */\n  const result = {\n    type: 'image',\n    url: state.resolve(String(properties.src || '') || null),\n    title: properties.title ? String(properties.title) : null,\n    alt: properties.alt ? String(properties.alt) : ''\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {InlineCode} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {InlineCode}\n *   mdast node.\n */\nexport function inlineCode(state, node) {\n  /** @type {InlineCode} */\n  const result = {type: 'inlineCode', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {Element, Properties} from 'hast'\n */\n\n/**\n * @typedef {[string, Value]} Option\n *   Option, where the item at `0` is the label, the item at `1` the value.\n *\n * @typedef {Array<Option>} Options\n *   List of options.\n *\n * @typedef {string | undefined} Value\n *   `value` field of option.\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {Readonly<Element>} node\n *   hast element to inspect.\n * @param {Properties | undefined} [explicitProperties]\n *   Properties to use, normally taken from `node`, but can be changed.\n * @returns {Options}\n *   Options.\n */\nexport function findSelectedOptions(node, explicitProperties) {\n  /** @type {Array<Element>} */\n  const selectedOptions = []\n  /** @type {Options} */\n  const values = []\n  const properties = explicitProperties || node.properties || {}\n  const options = findOptions(node)\n  const size =\n    Math.min(Number.parseInt(String(properties.size), 10), 0) ||\n    (properties.multiple ? 4 : 1)\n  let index = -1\n\n  while (++index < options.length) {\n    const option = options[index]\n\n    if (option && option.properties && option.properties.selected) {\n      selectedOptions.push(option)\n    }\n  }\n\n  const list = selectedOptions.length > 0 ? selectedOptions : options\n  const max = Math.min(list.length, size)\n  index = -1\n\n  while (++index < max) {\n    const option = list[index]\n    const properties = option.properties || {}\n    const content = toText(option)\n    const label = content || String(properties.label || '')\n    const value = String(properties.value || '') || content\n    values.push([value, label === value ? undefined : label])\n  }\n\n  return values\n}\n\n/**\n * @param {Element} node\n *   Parent to find in.\n * @returns {Array<Element>}\n *   Option elements.\n */\nfunction findOptions(node) {\n  /** @type {Array<Element>} */\n  const results = []\n  let index = -1\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if ('children' in child && Array.isArray(child.children)) {\n      results.push(...findOptions(child))\n    }\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'option' &&\n      (!child.properties || !child.properties.disabled)\n    ) {\n      results.push(child)\n    }\n  }\n\n  return results\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, Text} from 'mdast'\n * @import {Options} from '../util/find-selected-options.js'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\nconst defaultChecked = '[x]'\nconst defaultUnchecked = '[ ]'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<Link | Text> | Image | Text | undefined}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function input(state, node) {\n  const properties = node.properties || {}\n  const value = String(properties.value || properties.placeholder || '')\n\n  if (\n    properties.disabled ||\n    properties.type === 'hidden' ||\n    properties.type === 'file'\n  ) {\n    return\n  }\n\n  if (properties.type === 'checkbox' || properties.type === 'radio') {\n    /** @type {Text} */\n    const result = {\n      type: 'text',\n      value: properties.checked\n        ? state.options.checked || defaultChecked\n        : state.options.unchecked || defaultUnchecked\n    }\n    state.patch(node, result)\n    return result\n  }\n\n  if (properties.type === 'image') {\n    const alt = properties.alt || value\n\n    if (alt) {\n      /** @type {Image} */\n      const result = {\n        type: 'image',\n        url: state.resolve(String(properties.src || '') || null),\n        title: String(properties.title || '') || null,\n        alt: String(alt)\n      }\n      state.patch(node, result)\n      return result\n    }\n\n    return\n  }\n\n  /** @type {Options} */\n  let values = []\n\n  if (value) {\n    values = [[value, undefined]]\n  } else if (\n    // `list` is not supported on these types:\n    properties.type !== 'button' &&\n    properties.type !== 'file' &&\n    properties.type !== 'password' &&\n    properties.type !== 'reset' &&\n    properties.type !== 'submit' &&\n    properties.list\n  ) {\n    const list = String(properties.list)\n    const datalist = state.elementById.get(list)\n\n    if (datalist && datalist.tagName === 'datalist') {\n      values = findSelectedOptions(datalist, properties)\n    }\n  }\n\n  if (values.length === 0) {\n    return\n  }\n\n  // Hide password value.\n  if (properties.type === 'password') {\n    // Passwords don’t support `list`.\n    values[0] = ['•'.repeat(values[0][0].length), undefined]\n  }\n\n  if (properties.type === 'email' || properties.type === 'url') {\n    /** @type {Array<Link | Text>} */\n    const results = []\n    let index = -1\n\n    while (++index < values.length) {\n      const value = state.resolve(values[index][0])\n      /** @type {Link} */\n      const result = {\n        type: 'link',\n        title: null,\n        url: properties.type === 'email' ? 'mailto:' + value : value,\n        children: [{type: 'text', value: values[index][1] || value}]\n      }\n\n      results.push(result)\n\n      if (index !== values.length - 1) {\n        results.push({type: 'text', value: ', '})\n      }\n    }\n\n    return results\n  }\n\n  /** @type {Array<string>} */\n  const texts = []\n  let index = -1\n\n  while (++index < values.length) {\n    texts.push(\n      values[index][1]\n        ? values[index][1] + ' (' + values[index][0] + ')'\n        : values[index][0]\n    )\n  }\n\n  /** @type {Text} */\n  const result = {type: 'text', value: texts.join(', ')}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem} from 'mdast'\n */\n\n/**\n * @typedef ExtractResult\n *   Result of extracting a leading checkbox.\n * @property {Element | undefined} checkbox\n *   The checkbox that was removed, if any.\n * @property {Element} rest\n *   If there was a leading checkbox, a deep clone of the node w/o the leading\n *   checkbox; otherwise a reference to the given, untouched, node.\n */\n\nimport {phrasing} from 'hast-util-phrasing'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {ListItem}\n *   mdast node.\n */\nexport function li(state, node) {\n  // If the list item starts with a checkbox, remove the checkbox and mark the\n  // list item as a GFM task list item.\n  const {rest, checkbox} = extractLeadingCheckbox(node)\n  const checked = checkbox ? Boolean(checkbox.properties.checked) : null\n  const spread = spreadout(rest)\n  const children = state.toFlow(state.all(rest))\n\n  /** @type {ListItem} */\n  const result = {type: 'listItem', spread, checked, children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Check if an element should spread out.\n *\n * The reason to spread out a markdown list item is primarily whether writing\n * the equivalent in markdown, would yield a spread out item.\n *\n * A spread out item results in `<p>` and `</p>` tags.\n * Otherwise, the phrasing would be output directly.\n * We can check for that: if there’s a `<p>` element, spread it out.\n *\n * But what if there are no paragraphs?\n * In that case, we can also assume that if two “block” things were written in\n * an item, that it is spread out, because blocks are typically joined by blank\n * lines, which also means a spread item.\n *\n * Lastly, because in HTML things can be wrapped in a `<div>` or similar, we\n * delve into non-phrasing elements here to figure out if they themselves\n * contain paragraphs or 2 or more flow non-phrasing elements.\n *\n * @param {Readonly<Element>} node\n * @returns {boolean}\n */\nfunction spreadout(node) {\n  let index = -1\n  let seenFlow = false\n\n  while (++index < node.children.length) {\n    const child = node.children[index]\n\n    if (child.type === 'element') {\n      if (phrasing(child)) continue\n\n      if (child.tagName === 'p' || seenFlow || spreadout(child)) {\n        return true\n      }\n\n      seenFlow = true\n    }\n  }\n\n  return false\n}\n\n/**\n * Extract a leading checkbox from a list item.\n *\n * If there was a leading checkbox, makes a deep clone of the node w/o the\n * leading checkbox; otherwise a reference to the given, untouched, node is\n * given back.\n *\n * So for example:\n *\n * ```html\n * <li><input type=\"checkbox\">Text</li>\n * ```\n *\n * …becomes:\n *\n * ```html\n * <li>Text</li>\n * ```\n *\n * ```html\n * <li><p><input type=\"checkbox\">Text</p></li>\n * ```\n *\n * …becomes:\n *\n * ```html\n * <li><p>Text</p></li>\n * ```\n *\n * @param {Readonly<Element>} node\n * @returns {ExtractResult}\n */\nfunction extractLeadingCheckbox(node) {\n  const head = node.children[0]\n\n  if (\n    head &&\n    head.type === 'element' &&\n    head.tagName === 'input' &&\n    head.properties &&\n    (head.properties.type === 'checkbox' || head.properties.type === 'radio')\n  ) {\n    const rest = {...node, children: node.children.slice(1)}\n    return {checkbox: head, rest}\n  }\n\n  // The checkbox may be nested in another element.\n  // If the first element has children, look for a leading checkbox inside it.\n  //\n  // This only handles nesting in `<p>` elements, which is most common.\n  // It’s possible a leading checkbox might be nested in other types of flow or\n  // phrasing elements (and *deeply* nested, which is not possible with `<p>`).\n  // Limiting things to `<p>` elements keeps this simpler for now.\n  if (head && head.type === 'element' && head.tagName === 'p') {\n    const {checkbox, rest: restHead} = extractLeadingCheckbox(head)\n\n    if (checkbox) {\n      const rest = {...node, children: [restHead, ...node.children.slice(1)]}\n      return {checkbox, rest}\n    }\n  }\n\n  return {checkbox: undefined, rest: node}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {ListItem, List} from 'mdast'\n */\n\nimport {listItemsSpread} from '../util/list-items-spread.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {List}\n *   mdast node.\n */\nexport function list(state, node) {\n  const ordered = node.tagName === 'ol'\n  const children = state.toSpecificContent(state.all(node), create)\n  /** @type {number | null} */\n  let start = null\n\n  if (ordered) {\n    start =\n      node.properties && node.properties.start\n        ? Number.parseInt(String(node.properties.start), 10)\n        : 1\n  }\n\n  /** @type {List} */\n  const result = {\n    type: 'list',\n    ordered,\n    start,\n    spread: listItemsSpread(children),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {ListItem}\n */\nfunction create() {\n  return {type: 'listItem', spread: false, checked: null, children: []}\n}\n","/**\n * @import {} from 'mdast-util-to-hast'\n * @import {\n *   BlockContent,\n *   Delete,\n *   Link,\n *   Nodes,\n *   Paragraph,\n *   Parents,\n *   PhrasingContent,\n *   RootContent\n * } from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport {phrasing as hastPhrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {phrasing as mdastPhrasing} from 'mdast-util-phrasing'\nimport {dropSurroundingBreaks} from './drop-surrounding-breaks.js'\n\n/**\n * Check if there are phrasing mdast nodes.\n *\n * This is needed if a fragment is given, which could just be a sentence, and\n * doesn’t need a wrapper paragraph.\n *\n * @param {Array<Nodes>} nodes\n * @returns {boolean}\n */\nexport function wrapNeeded(nodes) {\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (!phrasing(node) || ('children' in node && wrapNeeded(node.children))) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Wrap runs of phrasing content into paragraphs, leaving the non-phrasing\n * content as-is.\n *\n * @param {Array<RootContent>} nodes\n *   Content.\n * @returns {Array<BlockContent>}\n *   Content where phrasing is wrapped in paragraphs.\n */\nexport function wrap(nodes) {\n  return runs(nodes, onphrasing, function (d) {\n    return d\n  })\n\n  /**\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<Paragraph>}\n   */\n  function onphrasing(nodes) {\n    return nodes.every(function (d) {\n      return d.type === 'text' ? whitespace(d.value) : false\n    })\n      ? []\n      : [{type: 'paragraph', children: dropSurroundingBreaks(nodes)}]\n  }\n}\n\n/**\n * @param {Delete | Link} node\n * @returns {Array<BlockContent>}\n */\nfunction split(node) {\n  return runs(node.children, onphrasing, onnonphrasing)\n\n  /**\n   * Use `parent`, put the phrasing run inside it.\n   *\n   * @param {Array<PhrasingContent>} nodes\n   * @returns {Array<BlockContent>}\n   */\n  function onphrasing(nodes) {\n    const newParent = cloneWithoutChildren(node)\n    newParent.children = nodes\n    // @ts-expect-error Assume fine.\n    return [newParent]\n  }\n\n  /**\n   * Use `child`, add `parent` as its first child, put the original children\n   * into `parent`.\n   * If `child` is not a parent, `parent` will not be added.\n   *\n   * @param {BlockContent} child\n   * @returns {BlockContent}\n   */\n  function onnonphrasing(child) {\n    if ('children' in child && 'children' in node) {\n      const newParent = cloneWithoutChildren(node)\n      const newChild = cloneWithoutChildren(child)\n      // @ts-expect-error Assume fine.\n      newParent.children = child.children\n      // @ts-expect-error Assume fine.\n      newChild.children.push(newParent)\n      return newChild\n    }\n\n    return {...child}\n  }\n}\n\n/**\n * Wrap all runs of mdast phrasing content in `paragraph` nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of input nodes.\n * @param {(nodes: Array<PhrasingContent>) => Array<BlockContent>} onphrasing\n *   Turn phrasing content into block content.\n * @param {(node: BlockContent) => BlockContent} onnonphrasing\n *   Map block content (defaults to keeping them as-is).\n * @returns {Array<BlockContent>}\n */\nfunction runs(nodes, onphrasing, onnonphrasing) {\n  const flattened = flatten(nodes)\n  /** @type {Array<BlockContent>} */\n  const result = []\n  /** @type {Array<PhrasingContent>} */\n  let queue = []\n  let index = -1\n\n  while (++index < flattened.length) {\n    const node = flattened[index]\n\n    if (phrasing(node)) {\n      queue.push(node)\n    } else {\n      if (queue.length > 0) {\n        result.push(...onphrasing(queue))\n        queue = []\n      }\n\n      // @ts-expect-error Assume non-phrasing.\n      result.push(onnonphrasing(node))\n    }\n  }\n\n  if (queue.length > 0) {\n    result.push(...onphrasing(queue))\n    queue = []\n  }\n\n  return result\n}\n\n/**\n * Flatten a list of nodes.\n *\n * @param {Array<RootContent>} nodes\n *   List of nodes, will unravel `delete` and `link`.\n * @returns {Array<RootContent>}\n *   Unraveled nodes.\n */\nfunction flatten(nodes) {\n  /** @type {Array<RootContent>} */\n  const flattened = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    // Straddling: some elements are *weird*.\n    // Namely: `map`, `ins`, `del`, and `a`, as they are hybrid elements.\n    // See: <https://html.spec.whatwg.org/#paragraphs>.\n    // Paragraphs are the weirdest of them all.\n    // See the straddling fixture for more info!\n    // `ins` is ignored in mdast, so we don’t need to worry about that.\n    // `map` maps to its content, so we don’t need to worry about that either.\n    // `del` maps to `delete` and `a` to `link`, so we do handle those.\n    // What we’ll do is split `node` over each of its children.\n    if (\n      (node.type === 'delete' || node.type === 'link') &&\n      wrapNeeded(node.children)\n    ) {\n      flattened.push(...split(node))\n    } else {\n      flattened.push(node)\n    }\n  }\n\n  return flattened\n}\n\n/**\n * Check if an mdast node is phrasing.\n *\n * Also supports checking embedded hast fields.\n *\n * @param {Nodes} node\n *   mdast node to check.\n * @returns {node is PhrasingContent}\n *   Whether `node` is phrasing content (includes nodes with `hName` fields\n *   set to phrasing hast element names).\n */\nfunction phrasing(node) {\n  const tagName = node.data && node.data.hName\n  return tagName\n    ? hastPhrasing({type: 'element', tagName, properties: {}, children: []})\n    : mdastPhrasing(node)\n}\n\n/**\n * @template {Parents} ParentType\n *   Parent type.\n * @param {ParentType} node\n *   Node to clone.\n * @returns {ParentType}\n *   Cloned node, without children.\n */\nfunction cloneWithoutChildren(node) {\n  return structuredClone({...node, children: []})\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Image, Link, PhrasingContent, RootContent as MdastRootContent, Root} from 'mdast'\n */\n\nimport {toString} from 'mdast-util-to-string'\nimport {EXIT, visit} from 'unist-util-visit'\nimport {wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent> | Link}\n *   mdast node.\n */\nexport function media(state, node) {\n  const properties = node.properties || {}\n  const poster = node.tagName === 'video' ? String(properties.poster || '') : ''\n  let source = String(properties.src || '')\n  let index = -1\n  let linkInFallbackContent = false\n  let nodes = state.all(node)\n\n  /** @type {Root} */\n  const fragment = {type: 'root', children: nodes}\n\n  visit(fragment, function (node) {\n    if (node.type === 'link') {\n      linkInFallbackContent = true\n      return EXIT\n    }\n  })\n\n  // If the content links to something, or if it’s not phrasing…\n  if (linkInFallbackContent || wrapNeeded(nodes)) {\n    return nodes\n  }\n\n  // Find the source.\n  while (!source && ++index < node.children.length) {\n    const child = node.children[index]\n\n    if (\n      child.type === 'element' &&\n      child.tagName === 'source' &&\n      child.properties\n    ) {\n      source = String(child.properties.src || '')\n    }\n  }\n\n  // If there’s a poster defined on the video, create an image.\n  if (poster) {\n    /** @type {Image} */\n    const image = {\n      type: 'image',\n      title: null,\n      url: state.resolve(poster),\n      alt: toString(nodes)\n    }\n    state.patch(node, image)\n    nodes = [image]\n  }\n\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (nodes)\n\n  // Link to the media resource.\n  /** @type {Link} */\n  const result = {\n    type: 'link',\n    title: properties.title ? String(properties.title) : null,\n    url: state.resolve(source),\n    children\n  }\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Paragraph, PhrasingContent} from 'mdast'\n */\n\nimport {dropSurroundingBreaks} from '../util/drop-surrounding-breaks.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Paragraph | undefined}\n *   mdast node.\n */\nexport function p(state, node) {\n  const children = dropSurroundingBreaks(\n    // Allow potentially “invalid” nodes, they might be unknown.\n    // We also support straddling later.\n    /** @type {Array<PhrasingContent>} */ (state.all(node))\n  )\n\n  if (children.length > 0) {\n    /** @type {Paragraph} */\n    const result = {type: 'paragraph', children}\n    state.patch(node, result)\n    return result\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RootContent as MdastRootContent} from 'mdast'\n */\n\nconst defaultQuotes = ['\"']\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Array<MdastRootContent>}\n *   mdast nodes.\n */\nexport function q(state, node) {\n  const quotes = state.options.quotes || defaultQuotes\n\n  state.qNesting++\n  const contents = state.all(node)\n  state.qNesting--\n\n  const quote = quotes[state.qNesting % quotes.length]\n  const head = contents[0]\n  const tail = contents[contents.length - 1]\n  const open = quote.charAt(0)\n  const close = quote.length > 1 ? quote.charAt(1) : quote\n\n  if (head && head.type === 'text') {\n    head.value = open + head.value\n  } else {\n    contents.unshift({type: 'text', value: open})\n  }\n\n  if (tail && tail.type === 'text') {\n    tail.value += close\n  } else {\n    contents.push({type: 'text', value: close})\n  }\n\n  return contents\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Root as HastRoot} from 'hast'\n * @import {Root as MdastRoot} from 'mdast'\n */\n\nimport {wrap, wrapNeeded} from '../util/wrap.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastRoot>} node\n *   hast root to transform.\n * @returns {MdastRoot}\n *   mdast node.\n */\nexport function root(state, node) {\n  let children = state.all(node)\n\n  if (state.options.document || wrapNeeded(children)) {\n    children = wrap(children)\n  }\n\n  /** @type {MdastRoot} */\n  const result = {type: 'root', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {findSelectedOptions} from '../util/find-selected-options.js'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text | undefined}\n *   mdast node.\n */\nexport function select(state, node) {\n  const values = findSelectedOptions(node)\n  let index = -1\n  /** @type {Array<string>} */\n  const results = []\n\n  while (++index < values.length) {\n    const value = values[index]\n    results.push(value[1] ? value[1] + ' (' + value[0] + ')' : value[0])\n  }\n\n  if (results.length > 0) {\n    /** @type {Text} */\n    const result = {type: 'text', value: results.join(', ')}\n    state.patch(node, result)\n    return result\n  }\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, Strong} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Strong}\n *   mdast node.\n */\nexport function strong(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {Strong} */\n  const result = {type: 'strong', children}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {PhrasingContent, TableCell} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableCell}\n *   mdast node.\n */\nexport function tableCell(state, node) {\n  // Allow potentially “invalid” nodes, they might be unknown.\n  // We also support straddling later.\n  const children = /** @type {Array<PhrasingContent>} */ (state.all(node))\n\n  /** @type {TableCell} */\n  const result = {type: 'tableCell', children}\n  state.patch(node, result)\n\n  if (node.properties) {\n    const rowSpan = node.properties.rowSpan\n    const colSpan = node.properties.colSpan\n\n    if (rowSpan || colSpan) {\n      const data = /** @type {Record<string, unknown>} */ (\n        result.data || (result.data = {})\n      )\n      if (rowSpan) data.hastUtilToMdastTemporaryRowSpan = rowSpan\n      if (colSpan) data.hastUtilToMdastTemporaryColSpan = colSpan\n    }\n  }\n\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {RowContent, TableRow} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {TableRow}\n *   mdast node.\n */\nexport function tableRow(state, node) {\n  const children = state.toSpecificContent(state.all(node), create)\n\n  /** @type {TableRow} */\n  const result = {type: 'tableRow', children}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * @returns {RowContent}\n */\nfunction create() {\n  return {type: 'tableCell', children: []}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {AlignType, RowContent, TableContent, Table, Text} from 'mdast'\n */\n\n/**\n * @typedef Info\n *   Inferred info on a table.\n * @property {Array<AlignType>} align\n *   Alignment.\n * @property {boolean} headless\n *   Whether a `thead` is missing.\n */\n\nimport {toText} from 'hast-util-to-text'\nimport {SKIP, visit} from 'unist-util-visit'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Table | Text}\n *   mdast node.\n */\n// eslint-disable-next-line complexity\nexport function table(state, node) {\n  // Ignore nested tables.\n  if (state.inTable) {\n    /** @type {Text} */\n    const result = {type: 'text', value: toText(node)}\n    state.patch(node, result)\n    return result\n  }\n\n  state.inTable = true\n\n  const {align, headless} = inspect(node)\n  const rows = state.toSpecificContent(state.all(node), createRow)\n\n  // Add an empty header row.\n  if (headless) {\n    rows.unshift(createRow())\n  }\n\n  let rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const row = rows[rowIndex]\n    const cells = state.toSpecificContent(row.children, createCell)\n    row.children = cells\n  }\n\n  let columns = 1\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = -1\n\n    while (++cellIndex < cells.length) {\n      const cell = cells[cellIndex]\n\n      if (cell.data) {\n        const data = /** @type {Record<string, unknown>} */ (cell.data)\n        const colSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryColSpan), 10) || 1\n        const rowSpan =\n          Number.parseInt(String(data.hastUtilToMdastTemporaryRowSpan), 10) || 1\n\n        if (colSpan > 1 || rowSpan > 1) {\n          let otherRowIndex = rowIndex - 1\n\n          while (++otherRowIndex < rowIndex + rowSpan) {\n            let colIndex = cellIndex - 1\n\n            while (++colIndex < cellIndex + colSpan) {\n              if (!rows[otherRowIndex]) {\n                // Don’t add rows that don’t exist.\n                // Browsers don’t render them either.\n                break\n              }\n\n              /** @type {Array<RowContent>} */\n              const newCells = []\n\n              if (otherRowIndex !== rowIndex || colIndex !== cellIndex) {\n                newCells.push({type: 'tableCell', children: []})\n              }\n\n              rows[otherRowIndex].children.splice(colIndex, 0, ...newCells)\n            }\n          }\n        }\n\n        // Clean the data fields.\n        if ('hastUtilToMdastTemporaryColSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryColSpan\n        if ('hastUtilToMdastTemporaryRowSpan' in cell.data)\n          delete cell.data.hastUtilToMdastTemporaryRowSpan\n        if (Object.keys(cell.data).length === 0) delete cell.data\n      }\n    }\n\n    if (cells.length > columns) columns = cells.length\n  }\n\n  // Add extra empty cells.\n  rowIndex = -1\n\n  while (++rowIndex < rows.length) {\n    const cells = rows[rowIndex].children\n    let cellIndex = cells.length - 1\n    while (++cellIndex < columns) {\n      cells.push({type: 'tableCell', children: []})\n    }\n  }\n\n  let alignIndex = align.length - 1\n  while (++alignIndex < columns) {\n    align.push(null)\n  }\n\n  state.inTable = false\n\n  /** @type {Table} */\n  const result = {type: 'table', align, children: rows}\n  state.patch(node, result)\n  return result\n}\n\n/**\n * Infer whether the HTML table has a head and how it aligns.\n *\n * @param {Readonly<Element>} node\n *   Table element to check.\n * @returns {Info}\n *   Info.\n */\nfunction inspect(node) {\n  /** @type {Info} */\n  const info = {align: [null], headless: true}\n  let rowIndex = 0\n  let cellIndex = 0\n\n  visit(node, function (child) {\n    if (child.type === 'element') {\n      // Don’t enter nested tables.\n      if (child.tagName === 'table' && node !== child) {\n        return SKIP\n      }\n\n      if (\n        (child.tagName === 'th' || child.tagName === 'td') &&\n        child.properties\n      ) {\n        if (!info.align[cellIndex]) {\n          const value = String(child.properties.align || '') || null\n\n          if (\n            value === 'center' ||\n            value === 'left' ||\n            value === 'right' ||\n            value === null\n          ) {\n            info.align[cellIndex] = value\n          }\n        }\n\n        // If there is a `th` in the first row, assume there is a header row.\n        if (info.headless && rowIndex < 2 && child.tagName === 'th') {\n          info.headless = false\n        }\n\n        cellIndex++\n      }\n      // If there is a `thead`, assume there is a header row.\n      else if (child.tagName === 'thead') {\n        info.headless = false\n      } else if (child.tagName === 'tr') {\n        rowIndex++\n        cellIndex = 0\n      }\n    }\n  })\n\n  return info\n}\n\n/**\n * @returns {RowContent}\n */\nfunction createCell() {\n  return {type: 'tableCell', children: []}\n}\n\n/**\n * @returns {TableContent}\n */\nfunction createRow() {\n  return {type: 'tableRow', children: []}\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Text as HastText} from 'hast'\n * @import {Text as MdastText} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<HastText>} node\n *   hast element to transform.\n * @returns {MdastText}\n *   mdast node.\n */\nexport function text(state, node) {\n  /** @type {MdastText} */\n  const result = {type: 'text', value: node.value}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\nimport {toText} from 'hast-util-to-text'\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function textarea(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: toText(node)}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Element} from 'hast'\n * @import {Text} from 'mdast'\n */\n\n/**\n * @param {State} state\n *   State.\n * @param {Readonly<Element>} node\n *   hast element to transform.\n * @returns {Text}\n *   mdast node.\n */\nexport function wbr(state, node) {\n  /** @type {Text} */\n  const result = {type: 'text', value: '\\u200B'}\n  state.patch(node, result)\n  return result\n}\n","/**\n * @import {State} from 'hast-util-to-mdast'\n * @import {Parents} from 'hast'\n */\n\nimport {a} from './a.js'\nimport {base} from './base.js'\nimport {blockquote} from './blockquote.js'\nimport {br} from './br.js'\nimport {code} from './code.js'\nimport {comment} from './comment.js'\nimport {del} from './del.js'\nimport {dl} from './dl.js'\nimport {em} from './em.js'\nimport {heading} from './heading.js'\nimport {hr} from './hr.js'\nimport {iframe} from './iframe.js'\nimport {img} from './img.js'\nimport {inlineCode} from './inline-code.js'\nimport {input} from './input.js'\nimport {li} from './li.js'\nimport {list} from './list.js'\nimport {media} from './media.js'\nimport {p} from './p.js'\nimport {q} from './q.js'\nimport {root} from './root.js'\nimport {select} from './select.js'\nimport {strong} from './strong.js'\nimport {tableCell} from './table-cell.js'\nimport {tableRow} from './table-row.js'\nimport {table} from './table.js'\nimport {text} from './text.js'\nimport {textarea} from './textarea.js'\nimport {wbr} from './wbr.js'\n\n/**\n * Default handlers for nodes.\n *\n * Each key is a node type, each value is a `NodeHandler`.\n */\nexport const nodeHandlers = {\n  comment,\n  doctype: ignore,\n  root,\n  text\n}\n\n/**\n * Default handlers for elements.\n *\n * Each key is an element name, each value is a `Handler`.\n */\nexport const handlers = {\n  // Ignore:\n  applet: ignore,\n  area: ignore,\n  basefont: ignore,\n  bgsound: ignore,\n  caption: ignore,\n  col: ignore,\n  colgroup: ignore,\n  command: ignore,\n  content: ignore,\n  datalist: ignore,\n  dialog: ignore,\n  element: ignore,\n  embed: ignore,\n  frame: ignore,\n  frameset: ignore,\n  isindex: ignore,\n  keygen: ignore,\n  link: ignore,\n  math: ignore,\n  menu: ignore,\n  menuitem: ignore,\n  meta: ignore,\n  nextid: ignore,\n  noembed: ignore,\n  noframes: ignore,\n  optgroup: ignore,\n  option: ignore,\n  param: ignore,\n  script: ignore,\n  shadow: ignore,\n  source: ignore,\n  spacer: ignore,\n  style: ignore,\n  svg: ignore,\n  template: ignore,\n  title: ignore,\n  track: ignore,\n\n  // Use children:\n  abbr: all,\n  acronym: all,\n  bdi: all,\n  bdo: all,\n  big: all,\n  blink: all,\n  button: all,\n  canvas: all,\n  cite: all,\n  data: all,\n  details: all,\n  dfn: all,\n  font: all,\n  ins: all,\n  label: all,\n  map: all,\n  marquee: all,\n  meter: all,\n  nobr: all,\n  noscript: all,\n  object: all,\n  output: all,\n  progress: all,\n  rb: all,\n  rbc: all,\n  rp: all,\n  rt: all,\n  rtc: all,\n  ruby: all,\n  slot: all,\n  small: all,\n  span: all,\n  sup: all,\n  sub: all,\n  tbody: all,\n  tfoot: all,\n  thead: all,\n  time: all,\n\n  // Use children as flow.\n  address: flow,\n  article: flow,\n  aside: flow,\n  body: flow,\n  center: flow,\n  div: flow,\n  fieldset: flow,\n  figcaption: flow,\n  figure: flow,\n  form: flow,\n  footer: flow,\n  header: flow,\n  hgroup: flow,\n  html: flow,\n  legend: flow,\n  main: flow,\n  multicol: flow,\n  nav: flow,\n  picture: flow,\n  section: flow,\n\n  // Handle.\n  a,\n  audio: media,\n  b: strong,\n  base,\n  blockquote,\n  br,\n  code: inlineCode,\n  dir: list,\n  dl,\n  dt: li,\n  dd: li,\n  del,\n  em,\n  h1: heading,\n  h2: heading,\n  h3: heading,\n  h4: heading,\n  h5: heading,\n  h6: heading,\n  hr,\n  i: em,\n  iframe,\n  img,\n  image: img,\n  input,\n  kbd: inlineCode,\n  li,\n  listing: code,\n  mark: em,\n  ol: list,\n  p,\n  plaintext: code,\n  pre: code,\n  q,\n  s: del,\n  samp: inlineCode,\n  select,\n  strike: del,\n  strong,\n  summary: p,\n  table,\n  td: tableCell,\n  textarea,\n  th: tableCell,\n  tr: tableRow,\n  tt: inlineCode,\n  u: em,\n  ul: list,\n  var: inlineCode,\n  video: media,\n  wbr,\n  xmp: code\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction all(state, node) {\n  return state.all(node)\n}\n\n/**\n * @param {State} state\n *   State.\n * @param {Parents} node\n *   Parent to transform.\n */\nfunction flow(state, node) {\n  return state.toFlow(state.all(node))\n}\n\n/**\n * @returns {undefined}\n */\nfunction ignore() {}\n","/**\n * @import {Element, Nodes, Parents} from 'hast'\n * @import {\n *   BlockContent as MdastBlockContent,\n *   DefinitionContent as MdastDefinitionContent,\n *   Nodes as MdastNodes,\n *   Parents as MdastParents,\n *   RootContent as MdastRootContent\n * } from 'mdast'\n */\n\n/**\n * @typedef {MdastBlockContent | MdastDefinitionContent} MdastFlowContent\n */\n\n/**\n * @callback All\n *   Transform the children of a hast parent to mdast.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n *\n * @callback Handle\n *   Handle a particular element.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {Element} element\n *   Element to transform.\n * @param {Parents | undefined} parent\n *   Parent of `element`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback NodeHandle\n *   Handle a particular node.\n * @param {State} state\n *   Info passed around about the current state.\n * @param {any} node\n *   Node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined | void}\n *   mdast node or nodes.\n *\n *   Note: `void` is included until TS nicely infers `undefined`.\n *\n * @callback One\n *   Transform a hast node to mdast.\n * @param {Nodes} node\n *   Expected hast node.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n *\n * @typedef Options\n *   Configuration.\n * @property {string | null | undefined} [checked='[x]']\n *   Value to use for a checked checkbox or radio input (default: `'[x]'`)\n * @property {boolean | null | undefined} [document]\n *   Whether the given tree represents a complete document (optional).\n *\n *   Applies when the `tree` is a `root` node.\n *   When the tree represents a complete document, then things are wrapped in\n *   paragraphs when needed, and otherwise they’re left as-is.\n *   The default checks for whether there’s mixed content: some phrasing nodes\n *   *and* some non-phrasing nodes.\n * @property {Record<string, Handle | null | undefined> | null | undefined} [handlers]\n *   Object mapping tag names to functions handling the corresponding elements\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {boolean | null | undefined} [newlines=false]\n *   Keep line endings when collapsing whitespace (default: `false`).\n *\n *   The default collapses to a single space.\n * @property {Record<string, NodeHandle | null | undefined> | null | undefined} [nodeHandlers]\n *   Object mapping node types to functions handling the corresponding nodes\n *   (optional).\n *\n *   Merged into the defaults.\n * @property {Array<string> | null | undefined} [quotes=['\"']]\n *   List of quotes to use (default: `['\"']`).\n *\n *   Each value can be one or two characters.\n *   When two, the first character determines the opening quote and the second\n *   the closing quote at that level.\n *   When one, both the opening and closing quote are that character.\n *\n *   The order in which the preferred quotes appear determines which quotes to\n *   use at which level of nesting.\n *   So, to prefer `‘’` at the first level of nesting, and `“”` at the second,\n *   pass `['‘’', '“”']`.\n *   If `<q>`s are nested deeper than the given amount of quotes, the markers\n *   wrap around: a third level of nesting when using `['«»', '‹›']` should\n *   have double guillemets, a fourth single, a fifth double again, etc.\n * @property {string | null | undefined} [unchecked='[ ]']\n *   Value to use for an unchecked checkbox or radio input (default: `'[ ]'`).\n *\n * @callback Patch\n *   Copy a node’s positional info.\n * @param {Nodes} from\n *   hast node to copy from.\n * @param {MdastNodes} to\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n *\n * @callback Resolve\n *   Resolve a URL relative to a base.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n *\n * @typedef State\n *   Info passed around about the current state.\n * @property {All} all\n *   Transform the children of a hast parent to mdast.\n * @property {boolean} baseFound\n *   Whether a `<base>` element was seen.\n * @property {Map<string, Element>} elementById\n *   Elements by their `id`.\n * @property {string | undefined} frozenBaseUrl\n *   `href` of `<base>`, if any.\n * @property {Record<string, Handle>} handlers\n *   Applied element handlers.\n * @property {boolean} inTable\n *   Whether we’re in a table.\n * @property {Record<string, NodeHandle>} nodeHandlers\n *   Applied node handlers.\n * @property {One} one\n *   Transform a hast node to mdast.\n * @property {Options} options\n *   User configuration.\n * @property {Patch} patch\n *   Copy a node’s positional info.\n * @property {number} qNesting\n *   Non-negative finite integer representing how deep we’re in `<q>`s.\n * @property {Resolve} resolve\n *   Resolve a URL relative to a base.\n * @property {ToFlow} toFlow\n *   Transform a list of mdast nodes to flow.\n * @property {<ChildType extends MdastNodes, ParentType extends MdastParents & {'children': Array<ChildType>}>(nodes: Array<MdastRootContent>, build: (() => ParentType)) => Array<ParentType>} toSpecificContent\n *   Turn arbitrary content into a list of a particular node type.\n *\n *   This is useful for example for lists, which must have list items as\n *   content.\n *   in this example, when non-items are found, they will be queued, and\n *   inserted into an adjacent item.\n *   When no actual items exist, one will be made with `build`.\n *\n * @callback ToFlow\n *   Transform a list of mdast nodes to flow.\n * @param {Array<MdastRootContent>} nodes\n *   mdast nodes.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\n\nimport {position} from 'unist-util-position'\nimport {handlers, nodeHandlers} from './handlers/index.js'\nimport {wrap} from './util/wrap.js'\n\nconst own = {}.hasOwnProperty\n\n/**\n * Create a state.\n *\n * @param {Readonly<Options>} options\n *   User configuration.\n * @returns {State}\n *   State.\n */\nexport function createState(options) {\n  return {\n    all,\n    baseFound: false,\n    elementById: new Map(),\n    frozenBaseUrl: undefined,\n    handlers: {...handlers, ...options.handlers},\n    inTable: false,\n    nodeHandlers: {...nodeHandlers, ...options.nodeHandlers},\n    one,\n    options,\n    patch,\n    qNesting: 0,\n    resolve,\n    toFlow,\n    toSpecificContent\n  }\n}\n\n/**\n * Transform the children of a hast parent to mdast.\n *\n * You might want to combine this with `toFlow` or `toSpecificContent`.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parents} parent\n *   Parent.\n * @returns {Array<MdastRootContent>}\n *   mdast children.\n */\nfunction all(parent) {\n  const children = parent.children || []\n  /** @type {Array<MdastRootContent>} */\n  const results = []\n  let index = -1\n\n  while (++index < children.length) {\n    const child = children[index]\n    // Content -> content.\n    const result =\n      /** @type {Array<MdastRootContent> | MdastRootContent | undefined} */ (\n        this.one(child, parent)\n      )\n\n    if (Array.isArray(result)) {\n      results.push(...result)\n    } else if (result) {\n      results.push(result)\n    }\n  }\n\n  return results\n}\n\n/**\n * Transform a hast node to mdast.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Nodes} node\n *   hast node to transform.\n * @param {Parents | undefined} parent\n *   Parent of `node`.\n * @returns {Array<MdastNodes> | MdastNodes | undefined}\n *   mdast result.\n */\nfunction one(node, parent) {\n  if (node.type === 'element') {\n    if (node.properties && node.properties.dataMdast === 'ignore') {\n      return\n    }\n\n    if (own.call(this.handlers, node.tagName)) {\n      return this.handlers[node.tagName](this, node, parent) || undefined\n    }\n  } else if (own.call(this.nodeHandlers, node.type)) {\n    return this.nodeHandlers[node.type](this, node, parent) || undefined\n  }\n\n  // Unknown literal.\n  if ('value' in node && typeof node.value === 'string') {\n    /** @type {MdastRootContent} */\n    const result = {type: 'text', value: node.value}\n    this.patch(node, result)\n    return result\n  }\n\n  // Unknown parent.\n  if ('children' in node) {\n    return this.all(node)\n  }\n}\n\n/**\n * Copy a node’s positional info.\n *\n * @param {Nodes} origin\n *   hast node to copy from.\n * @param {MdastNodes} node\n *   mdast node to copy into.\n * @returns {undefined}\n *   Nothing.\n */\nfunction patch(origin, node) {\n  if (origin.position) node.position = position(origin)\n}\n\n/**\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} url\n *   Possible URL value.\n * @returns {string}\n *   URL, resolved to a `base` element, if any.\n */\nfunction resolve(url) {\n  const base = this.frozenBaseUrl\n\n  if (url === null || url === undefined) {\n    return ''\n  }\n\n  if (base) {\n    return String(new URL(url, base))\n  }\n\n  return url\n}\n\n/**\n * Transform a list of mdast nodes to flow.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Array<MdastRootContent>} nodes\n *   Parent.\n * @returns {Array<MdastFlowContent>}\n *   mdast flow children.\n */\nfunction toFlow(nodes) {\n  return wrap(nodes)\n}\n\n/**\n * Turn arbitrary content into a particular node type.\n *\n * This is useful for example for lists, which must have list items as content.\n * in this example, when non-items are found, they will be queued, and\n * inserted into an adjacent item.\n * When no actual items exist, one will be made with `build`.\n *\n * @template {MdastNodes} ChildType\n *   Node type of children.\n * @template {MdastParents & {'children': Array<ChildType>}} ParentType\n *   Node type of parent.\n * @param {Array<MdastRootContent>} nodes\n *   Nodes, which are either `ParentType`, or will be wrapped in one.\n * @param {() => ParentType} build\n *   Build a parent if needed (must have empty `children`).\n * @returns {Array<ParentType>}\n *   List of parents.\n */\nfunction toSpecificContent(nodes, build) {\n  const reference = build()\n  /** @type {Array<ParentType>} */\n  const results = []\n  /** @type {Array<ChildType>} */\n  let queue = []\n  let index = -1\n\n  while (++index < nodes.length) {\n    const node = nodes[index]\n\n    if (expectedParent(node)) {\n      if (queue.length > 0) {\n        node.children.unshift(...queue)\n        queue = []\n      }\n\n      results.push(node)\n    } else {\n      // Assume `node` can be a child of `ParentType`.\n      // If we start checking nodes, we’d run into problems with unknown nodes,\n      // which we do want to support.\n      const child = /** @type {ChildType} */ (node)\n      queue.push(child)\n    }\n  }\n\n  if (queue.length > 0) {\n    let node = results[results.length - 1]\n\n    if (!node) {\n      node = build()\n      results.push(node)\n    }\n\n    node.children.push(...queue)\n    queue = []\n  }\n\n  return results\n\n  /**\n   * @param {MdastNodes} node\n   * @returns {node is ParentType}\n   */\n  function expectedParent(node) {\n    return node.type === reference.type\n  }\n}\n","/**\n * @import {Options} from 'hast-util-to-mdast'\n * @import {Nodes} from 'hast'\n * @import {Nodes as MdastNodes, RootContent as MdastRootContent} from 'mdast'\n */\n\nimport structuredClone from '@ungap/structured-clone'\nimport rehypeMinifyWhitespace from 'rehype-minify-whitespace'\nimport {visit} from 'unist-util-visit'\nimport {createState} from './state.js'\n\n/** @type {Readonly<Options>} */\nconst emptyOptions = {}\n\n/**\n * Transform hast to mdast.\n *\n * @param {Readonly<Nodes>} tree\n *   hast tree to transform.\n * @param {Readonly<Options> | null | undefined} [options]\n *   Configuration (optional).\n * @returns {MdastNodes}\n *   mdast tree.\n */\nexport function toMdast(tree, options) {\n  // We have to clone, cause we’ll use `rehype-minify-whitespace` on the tree,\n  // which modifies.\n  const cleanTree = structuredClone(tree)\n  const settings = options || emptyOptions\n  const transformWhitespace = rehypeMinifyWhitespace({\n    newlines: settings.newlines === true\n  })\n  const state = createState(settings)\n  /** @type {MdastNodes} */\n  let mdast\n\n  // @ts-expect-error: fine to pass an arbitrary node.\n  transformWhitespace(cleanTree)\n\n  visit(cleanTree, function (node) {\n    if (node && node.type === 'element' && node.properties) {\n      const id = String(node.properties.id || '') || undefined\n\n      if (id && !state.elementById.has(id)) {\n        state.elementById.set(id, node)\n      }\n    }\n  })\n\n  const result = state.one(cleanTree, undefined)\n\n  if (!result) {\n    mdast = {type: 'root', children: []}\n  } else if (Array.isArray(result)) {\n    // Assume content.\n    const children = /** @type {Array<MdastRootContent>} */ (result)\n    mdast = {type: 'root', children}\n  } else {\n    mdast = result\n  }\n\n  // Collapse text nodes, and fix whitespace.\n  //\n  // Most of this is taken care of by `rehype-minify-whitespace`, but\n  // we’re generating some whitespace too, and some nodes are in the end\n  // ignored.\n  // So clean up.\n  visit(mdast, function (node, index, parent) {\n    if (node.type === 'text' && index !== undefined && parent) {\n      const previous = parent.children[index - 1]\n\n      if (previous && previous.type === node.type) {\n        previous.value += node.value\n        parent.children.splice(index, 1)\n\n        if (previous.position && node.position) {\n          previous.position.end = node.position.end\n        }\n\n        // Iterate over the previous node again, to handle its total value.\n        return index - 1\n      }\n\n      node.value = node.value.replace(/[\\t ]*(\\r?\\n|\\r)[\\t ]*/, '$1')\n\n      // We don’t care about other phrasing nodes in between (e.g., `[ asd ]()`),\n      // as there the whitespace matters.\n      if (\n        parent &&\n        (parent.type === 'heading' ||\n          parent.type === 'paragraph' ||\n          parent.type === 'root')\n      ) {\n        if (!index) {\n          node.value = node.value.replace(/^[\\t ]+/, '')\n        }\n\n        if (index === parent.children.length - 1) {\n          node.value = node.value.replace(/[\\t ]+$/, '')\n        }\n      }\n\n      if (!node.value) {\n        parent.children.splice(index, 1)\n        return index\n      }\n    }\n  })\n\n  return mdast\n}\n","/**\n * @import {Root as HastRoot} from 'hast'\n * @import {Options} from 'hast-util-to-mdast'\n * @import {Root as MdastRoot} from 'mdast'\n * @import {Processor} from 'unified'\n * @import {VFile} from 'vfile'\n */\n\n/**\n * @callback TransformBridge\n *   Bridge-mode.\n *\n *   Runs the destination with the new mdast tree.\n *   Discards result.\n * @param {HastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {Promise<undefined>}\n *   Nothing.\n *\n * @callback TransformMutate\n *  Mutate-mode.\n *\n *  Further transformers run on the mdast tree.\n * @param {HastRoot} tree\n *   Tree.\n * @param {VFile} file\n *   File.\n * @returns {MdastRoot}\n *   Tree (mdast).\n */\n\nimport {toMdast} from 'hast-util-to-mdast'\n\n/** @satisfies {Options} */\nconst defaults = {document: true}\n\n/**\n * Turn HTML into markdown.\n *\n * ###### Notes\n *\n * *   if a processor is given, runs the (remark) plugins used on it with an\n *     mdast tree, then discards the result (*bridge mode*)\n * *   otherwise, returns an mdast tree, the plugins used after `rehypeRemark`\n *     are remark plugins (*mutate mode*)\n *\n * > 👉 **Note**: It’s highly unlikely that you want to pass a `processor`.\n *\n * @overload\n * @param {Processor} processor\n * @param {Options | null | undefined} [options]\n * @returns {TransformBridge}\n *\n * @overload\n * @param {Options | null | undefined} [options]\n * @returns {TransformMutate}\n *\n * @overload\n * @param {Options | Processor | null | undefined} [destination]\n * @param {Options | null | undefined} [options]\n * @returns {TransformBridge | TransformMutate}\n *\n * @param {Options | Processor | null | undefined} [destination]\n *   Processor or configuration (optional).\n * @param {Options | null | undefined} [options]\n *   When a processor was given, configuration (optional).\n * @returns {TransformBridge | TransformMutate}\n *   Transform.\n */\nexport default function rehypeRemark(destination, options) {\n  if (destination && 'run' in destination) {\n    /**\n     * @type {TransformBridge}\n     */\n    return async function (tree, file) {\n      const mdastTree = toMdast(tree, {...defaults, ...options})\n      await destination.run(mdastTree, file)\n    }\n  }\n\n  /**\n   * @type {TransformMutate}\n   */\n  return function (tree) {\n    return /** @type {MdastRoot} */ (\n      toMdast(tree, {...defaults, ...destination})\n    )\n  }\n}\n"],"names":["rehypeMinifyWhitespace","options","tree","minifyWhitespace","a","state","node","properties","children","result","base","blockquote","br","findAfter","parent","index","test","is","convert","searchLineFeeds","searchTabOrSpaces","convertElement","cell","isCell","p","row","notRendered","hidden","closedDialog","blockOrCaption","toText","options_","block","whitespace","inferWhitespace","results","collectText","renderedTextCollection","count","value","info","collectElement","collectPreText","items","prefix","suffix","lines","start","match","end","trimAndCollapseSpacesAndTabs","join","breakBefore","breakAfter","trimTrailingLines","input","code","classList","lang","child","comment","del","listItemsSpread","dl","clean","groups","group","previous","content","handle","nodes","listItems","create","em","dropSurroundingBreaks","heading","depth","hr","iframe","source","title","img","inlineCode","findSelectedOptions","explicitProperties","selectedOptions","values","findOptions","size","option","list","max","label","defaultChecked","defaultUnchecked","alt","datalist","texts","li","rest","checkbox","extractLeadingCheckbox","checked","spread","spreadout","seenFlow","phrasing","head","restHead","ordered","wrapNeeded","wrap","runs","onphrasing","d","split","onnonphrasing","newParent","cloneWithoutChildren","newChild","flattened","flatten","queue","tagName","hastPhrasing","mdastPhrasing","structuredClone","media","poster","linkInFallbackContent","visit","EXIT","image","toString","defaultQuotes","q","quotes","contents","quote","tail","open","close","root","select","strong","tableCell","rowSpan","colSpan","data","tableRow","table","align","headless","inspect","rows","createRow","rowIndex","cells","createCell","columns","cellIndex","otherRowIndex","colIndex","newCells","alignIndex","SKIP","text","textarea","wbr","nodeHandlers","ignore","handlers","all","flow","own","createState","one","patch","resolve","toFlow","toSpecificContent","origin","position","url","build","reference","expectedParent","emptyOptions","toMdast","cleanTree","settings","transformWhitespace","mdast","id","defaults","rehypeRemark","destination","file","mdastTree"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40]}