{"version":3,"file":"index-e457e8cf.js","sources":["../../node_modules/html-whitespace-sensitive-tag-names/lib/index.js","../../node_modules/hast-util-format/lib/index.js","../../node_modules/rehype-format/lib/index.js"],"sourcesContent":["/**\n * List of HTML tag names that are whitespace sensitive.\n */\nexport const whitespaceSensitiveTagNames = [\n  'pre',\n  'script',\n  'style',\n  'textarea'\n]\n","/**\n * @import {Nodes, RootContent, Root} from 'hast'\n * @import {BuildVisitor} from 'unist-util-visit-parents'\n * @import {Options, State} from './types.js'\n */\n\nimport {embedded} from 'hast-util-embedded'\nimport {minifyWhitespace} from 'hast-util-minify-whitespace'\nimport {phrasing} from 'hast-util-phrasing'\nimport {whitespace} from 'hast-util-whitespace'\nimport {whitespaceSensitiveTagNames} from 'html-whitespace-sensitive-tag-names'\nimport {SKIP, visitParents} from 'unist-util-visit-parents'\n\n/** @type {Options} */\nconst emptyOptions = {}\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Root} tree\n *   Tree.\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns {undefined}\n *   Nothing.\n */\nexport function format(tree, options) {\n  const settings = options || emptyOptions\n\n  /** @type {State} */\n  const state = {\n    blanks: settings.blanks || [],\n    head: false,\n    indentInitial: settings.indentInitial !== false,\n    indent:\n      typeof settings.indent === 'number'\n        ? ' '.repeat(settings.indent)\n        : typeof settings.indent === 'string'\n          ? settings.indent\n          : '  '\n  }\n\n  minifyWhitespace(tree, {newlines: true})\n\n  visitParents(tree, visitor)\n\n  /**\n   * @type {BuildVisitor<Root>}\n   */\n  function visitor(node, parents) {\n    if (!('children' in node)) {\n      return\n    }\n\n    if (node.type === 'element' && node.tagName === 'head') {\n      state.head = true\n    }\n\n    if (state.head && node.type === 'element' && node.tagName === 'body') {\n      state.head = false\n    }\n\n    if (\n      node.type === 'element' &&\n      whitespaceSensitiveTagNames.includes(node.tagName)\n    ) {\n      return SKIP\n    }\n\n    // Don’t indent content of whitespace-sensitive nodes / inlines.\n    if (node.children.length === 0 || !padding(state, node)) {\n      return\n    }\n\n    let level = parents.length\n\n    if (!state.indentInitial) {\n      level--\n    }\n\n    let eol = false\n\n    // Indent newlines in `text`.\n    for (const child of node.children) {\n      if (child.type === 'comment' || child.type === 'text') {\n        if (child.value.includes('\\n')) {\n          eol = true\n        }\n\n        child.value = child.value.replace(\n          / *\\n/g,\n          '$&' + state.indent.repeat(level)\n        )\n      }\n    }\n\n    /** @type {Array<RootContent>} */\n    const result = []\n    /** @type {RootContent | undefined} */\n    let previous\n\n    for (const child of node.children) {\n      if (padding(state, child) || (eol && !previous)) {\n        addBreak(result, level, child)\n        eol = true\n      }\n\n      previous = child\n      result.push(child)\n    }\n\n    if (previous && (eol || padding(state, previous))) {\n      // Ignore trailing whitespace (if that already existed), as we’ll add\n      // properly indented whitespace.\n      if (whitespace(previous)) {\n        result.pop()\n        previous = result[result.length - 1]\n      }\n\n      addBreak(result, level - 1)\n    }\n\n    node.children = result\n  }\n\n  /**\n   * @param {Array<RootContent>} list\n   *   Nodes.\n   * @param {number} level\n   *   Indentation level.\n   * @param {RootContent | undefined} [next]\n   *   Next node.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  function addBreak(list, level, next) {\n    const tail = list[list.length - 1]\n    const previous = tail && whitespace(tail) ? list[list.length - 2] : tail\n    const replace =\n      (blank(state, previous) && blank(state, next) ? '\\n\\n' : '\\n') +\n      state.indent.repeat(Math.max(level, 0))\n\n    if (tail && tail.type === 'text') {\n      tail.value = whitespace(tail) ? replace : tail.value + replace\n    } else {\n      list.push({type: 'text', value: replace})\n    }\n  }\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes | undefined} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` is a blank.\n */\nfunction blank(state, node) {\n  return Boolean(\n    node &&\n      node.type === 'element' &&\n      state.blanks.length > 0 &&\n      state.blanks.includes(node.tagName)\n  )\n}\n\n/**\n * @param {State} state\n *   Info passed around.\n * @param {Nodes} node\n *   Node.\n * @returns {boolean}\n *   Whether `node` should be padded.\n */\nfunction padding(state, node) {\n  return (\n    node.type === 'root' ||\n    (node.type === 'element'\n      ? state.head ||\n        node.tagName === 'script' ||\n        embedded(node) ||\n        !phrasing(node)\n      : false)\n  )\n}\n","/**\n * @import {Options} from 'hast-util-format'\n * @import {Root} from 'hast'\n */\n\nimport {format} from 'hast-util-format'\n\n/**\n * Format whitespace in HTML.\n *\n * @param {Options | null | undefined} [options]\n *   Configuration (optional).\n * @returns\n *   Transform.\n */\nexport default function rehypeFormat(options) {\n  /**\n   * Transform.\n   *\n   * @param {Root} tree\n   *   Tree.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  return function (tree) {\n    format(tree, options)\n  }\n}\n"],"names":["whitespaceSensitiveTagNames","emptyOptions","format","tree","options","settings","state","minifyWhitespace","visitParents","visitor","node","parents","SKIP","padding","level","eol","child","result","previous","addBreak","whitespace","list","next","tail","replace","blank","embedded","phrasing","rehypeFormat"],"mappings":"6IAGO,MAAMA,EAA8B,CACzC,MACA,SACA,QACA,UACF,ECMMC,EAAe,CAAE,EAYhB,SAASC,EAAOC,EAAMC,EAAS,CACpC,MAAMC,EAAWD,GAAWH,EAGtBK,EAAQ,CACZ,OAAQD,EAAS,QAAU,CAAE,EAC7B,KAAM,GACN,cAAeA,EAAS,gBAAkB,GAC1C,OACE,OAAOA,EAAS,QAAW,SACvB,IAAI,OAAOA,EAAS,MAAM,EAC1B,OAAOA,EAAS,QAAW,SACzBA,EAAS,OACT,IACT,EAEDE,EAAiBJ,EAAM,CAAC,SAAU,EAAI,CAAC,EAEvCK,EAAaL,EAAMM,CAAO,EAK1B,SAASA,EAAQC,EAAMC,EAAS,CAC9B,GAAI,EAAE,aAAcD,GAClB,OAWF,GARIA,EAAK,OAAS,WAAaA,EAAK,UAAY,SAC9CJ,EAAM,KAAO,IAGXA,EAAM,MAAQI,EAAK,OAAS,WAAaA,EAAK,UAAY,SAC5DJ,EAAM,KAAO,IAIbI,EAAK,OAAS,WACdV,EAA4B,SAASU,EAAK,OAAO,EAEjD,OAAOE,EAIT,GAAIF,EAAK,SAAS,SAAW,GAAK,CAACG,EAAQP,EAAOI,CAAI,EACpD,OAGF,IAAII,EAAQH,EAAQ,OAEfL,EAAM,eACTQ,IAGF,IAAIC,EAAM,GAGV,UAAWC,KAASN,EAAK,UACnBM,EAAM,OAAS,WAAaA,EAAM,OAAS,UACzCA,EAAM,MAAM,SAAS;AAAA,CAAI,IAC3BD,EAAM,IAGRC,EAAM,MAAQA,EAAM,MAAM,QACxB,QACA,KAAOV,EAAM,OAAO,OAAOQ,CAAK,CACjC,GAKL,MAAMG,EAAS,CAAE,EAEjB,IAAIC,EAEJ,UAAWF,KAASN,EAAK,UACnBG,EAAQP,EAAOU,CAAK,GAAMD,GAAO,CAACG,KACpCC,EAASF,EAAQH,EAAOE,CAAK,EAC7BD,EAAM,IAGRG,EAAWF,EACXC,EAAO,KAAKD,CAAK,EAGfE,IAAaH,GAAOF,EAAQP,EAAOY,CAAQ,KAGzCE,EAAWF,CAAQ,IACrBD,EAAO,IAAK,EACZC,EAAWD,EAAOA,EAAO,OAAS,CAAC,GAGrCE,EAASF,EAAQH,EAAQ,CAAC,GAG5BJ,EAAK,SAAWO,CACjB,CAYD,SAASE,EAASE,EAAMP,EAAOQ,EAAM,CACnC,MAAMC,EAAOF,EAAKA,EAAK,OAAS,CAAC,EAC3BH,EAAWK,GAAQH,EAAWG,CAAI,EAAIF,EAAKA,EAAK,OAAS,CAAC,EAAIE,EAC9DC,GACHC,EAAMnB,EAAOY,CAAQ,GAAKO,EAAMnB,EAAOgB,CAAI,EAAI;AAAA;AAAA,EAAS;AAAA,GACzDhB,EAAM,OAAO,OAAO,KAAK,IAAIQ,EAAO,CAAC,CAAC,EAEpCS,GAAQA,EAAK,OAAS,OACxBA,EAAK,MAAQH,EAAWG,CAAI,EAAIC,EAAUD,EAAK,MAAQC,EAEvDH,EAAK,KAAK,CAAC,KAAM,OAAQ,MAAOG,CAAO,CAAC,CAE3C,CACH,CAUA,SAASC,EAAMnB,EAAOI,EAAM,CAC1B,MAAO,GACLA,GACEA,EAAK,OAAS,WACdJ,EAAM,OAAO,OAAS,GACtBA,EAAM,OAAO,SAASI,EAAK,OAAO,EAExC,CAUA,SAASG,EAAQP,EAAOI,EAAM,CAC5B,OACEA,EAAK,OAAS,SACbA,EAAK,OAAS,UACXJ,EAAM,MACNI,EAAK,UAAY,UACjBgB,EAAShB,CAAI,GACb,CAACiB,EAASjB,CAAI,EACd,GAER,CC1Ke,SAASkB,EAAaxB,EAAS,CAS5C,OAAO,SAAUD,EAAM,CACrBD,EAAOC,EAAMC,CAAO,CACrB,CACH","x_google_ignoreList":[0,1,2]}